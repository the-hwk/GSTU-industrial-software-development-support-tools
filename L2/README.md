# Инструменты промышленной поддержки разработки программного обеспечения
## Лабораторная работа №2 (16 ч)

### Тема: Системы сборки ПО. Maven и Gradle.

**Общая цель работы:** изучить принципы работы и возможности современных систем автоматической сборки на примере **Maven** и **Gradle**. Освоить практические навыки по созданию и управлению проектами, управлению зависимостями, жизненным циклом сборки, а также познакомиться с продвинутыми техниками, такими как многомодульные проекты, профили сборки и оптимизация производительности.

*Предлагается дополнить проект, разработанный в рамках первой лабораторной работы, тестовыми сценариями и выполнить ручную сборку.*

**Примечание:** работа с системами сборки осуществляется преимущественно через CLI (консоль), однако допускается использование встроенных инструментов в IDE.

---

## Часть 1. Введение в Maven: основы и жизненный цикл (4 ч)

### Тема 2.1: Введение в системы сборки. Структура POM, фазы жизненного цикла, управление зависимостями.
**Цель:** понять роль систем сборки, изучить базовую структуру **Maven**-проекта, освоить работу с файлом pom.xml, научиться управлять зависимостями и выполнять основные фазы жизненного цикла.

#### Ход работы

**1. Подготовка и создание проекта**
* Установить Apache Maven и убедиться, что он доступен из командной строки (`mvn -v`).
* Создать новый **Maven**-проект с помощью архетипа. Архетип — это шаблон проекта.
* Для простого консольного приложения на Java используйте `maven-archetype-quickstart`.
    ```bash
    mvn archetype:generate -DgroupId=by.gstu.project -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4 -DinteractiveMode=false
    ```
* Изучить структуру созданного проекта: расположение исходного кода (`src/main/java`), тестов (`src/test/java`) и файла-дескриптора `pom.xml`.

**2. Изучение Project Object Model (POM)**
* Открыть файл `pom.xml`. Найти и изучить основные координаты проекта:
    * `groupId`: Идентификатор вашей компании или организации (например, `by.gstu.project`).
    * `artifactId`: Идентификатор конкретного проекта (например, `my-app`).
    * `version`: Версия проекта (например, `1.0-SNAPSHOT`).
* Обратить внимание на секцию `<dependencies>`. По умолчанию там будет зависимость для тестирования (JUnit).

**3. Управление зависимостями**

### **Теория**

Maven автоматически загружает и управляет библиотеками, необходимыми для вашего проекта. Вы просто указываете `groupId`, `artifactId` и `version` нужной зависимости в секции `<dependencies>`. Maven загрузит их из центрального репозитория.

### **Пример**

* Найти в репозитории Maven Central популярную библиотеку, например, **JUnit 5**.
* Добавить зависимость в `pom.xml` внутри секции `<dependencies>`.
Добавим в наш проект зависимость для модульного тестирования **JUnit 5** и популярную библиотеку **Apache Commons Lang**.

```xml
<dependencies>
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter-api</artifactId>
        <version>5.10.0</version>
        <scope>test</scope>
    </dependency>

    <dependency>
        <groupId>org.apache.commons</groupId>
        <artifactId>commons-lang3</artifactId>
        <version>3.13.0</version>
    </dependency>
</dependencies>
```

* Выполнить команду `mvn dependency:resolve`, чтобы **Maven** скачал указанную библиотеку и ее транзитивные зависимости. Проверить локальный репозиторий (`~/.m2/repository`).

-----

## 4. Жизненный цикл сборки**

### **Теория**

Жизненный цикл Maven состоит из ряда фаз, которые выполняются последовательно. Основные фазы:

* Изучить основные фазы жизненного цикла **Maven**:
    * `validate`: проверяет корректность информации о проекте.
    * `compile`: компилирует исходный код проекта.
    * `test`: запускает тесты с использованием подходящего фреймворка.
    * `package`: упаковывает скомпилированный код в распространяемый формат, например, JAR.
    * `install`: устанавливает пакет в локальный репозиторий для использования в качестве зависимости в других проектах.
    * `deploy`: копирует финальный артефакт в удаленный репозиторий.

### **Пример**
* Последовательно выполнить команды и наблюдать за результатом:
Для выполнения фазы, достаточно ввести в терминале команду `mvn <фаза>`.
  * Чтобы скомпилировать код: `mvn compile`
  * Чтобы запустить тесты: `mvn test`
  * Чтобы собрать пакет: `mvn package`
  * Чтобы установить в локальный репозиторий: `mvn install`
	
* Обратить внимание, что запуск фазы `package` автоматически вызывает все предыдущие фазы (`validate`, `compile`, `test`).
* Создать коммит в **Git**, фиксирующий базовую структуру проекта.

----- 


#### Тема 2.2: Плагины (surefire, shade), многомодульные проекты, профили, интеграция с репозиториями.

**Цель:** научиться настраивать сборку с помощью плагинов, создавать сложные многомодульные проекты, управлять конфигурацией сборки через профили и публиковать артефакты в удаленные репозитории.

## 6\. Плагины (surefire, shade)

### **Теория**

**Плагины** — это сердце Maven. Они выполняют конкретные задачи во время сборки. **Surefire** — один из самых важных. Он запускает тесты и создает отчеты. Эти отчеты помогают вам увидеть, какие тесты прошли успешно, а какие — нет.

### **Пример**

После выполнения `mvn test` перейдите в директорию `target/surefire-reports`. Вы найдете там XML и текстовые файлы с результатами тестов. Например, `TEST-com.mycompany.lab2.StringUtilsTest.xml` будет содержать подробную информацию о каждом тесте, включая время выполнения и статус.

Чтобы получить более читаемый отчет, можно использовать плагин **Maven Site**, который генерирует целый сайт проекта.

-----

#### Ход работы

**1. Работа с плагинами**
* **Surefire Plugin:** Этот плагин отвечает за запуск тестов. Настроить его в `pom.xml` для использования определенной версии JUnit и вывода отчетов.
    ```xml
    <build>
      <plugins>
        <plugin>
          <groupId>org.apache.maven.plugins</groupId>
          <artifactId>maven-surefire-plugin</artifactId>
          <version>2.22.2</version>
        </plugin>
      </plugins>
    </build>
    ```
* **Shade Plugin:** Этот плагин используется для создания "uber-JAR" (или "fat-JAR") — JAR-файла, который включает в себя все зависимости проекта. Это удобно для распространения консольных приложений.
    * Добавить плагин в секцию `<plugins>`.
    * Настроить его для указания главного класса (Main-Class) в манифесте JAR-файла.
    ```xml
    <plugin>
      <groupId>org.apache.maven.plugins</groupId>
      <artifactId>maven-shade-plugin</artifactId>
      <version>3.2.4</version>
      <executions>
        <execution>
          <phase>package</phase>
          <goals>
            <goal>shade</goal>
          </goals>
          <configuration>
            <transformers>
              <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
                <mainClass>by.gstu.project.App</mainClass>
              </transformer>
            </transformers>
          </configuration>
        </execution>
      </executions>
    </plugin>
    ```
* Выполнить `mvn package` и убедиться, что в папке `target` создался `my-app-1.0-SNAPSHOT.jar`, который можно запустить командой `java -jar my-app-1.0-SNAPSHOT.jar`.

**2. Создание многомодульного проекта**
* Преобразовать текущий проект в многомодульный со следующей архитектурой:
    * `parent-project` (родительский POM, тип `<packaging>pom</packaging>`)
    * `core-module` (бизнес-логика, JAR)
    * `cli-module` (консольный интерфейс, JAR, зависит от `core-module`)
* Создать родительский `pom.xml`, в котором перечислить модули (`<modules>`) и общие зависимости (`<dependencyManagement>`).
* В `cli-module` добавить зависимость на `core-module`.
* Выполнить `mvn package` из корневой директории `parent-project`. **Maven** автоматически определит порядок сборки модулей.

**3. Профили сборки**
* Профили позволяют настраивать сборку для разных окружений (например, development и production).
* В родительском `pom.xml` создать два профиля:
    * `dev`: активируется по умолчанию, не выполняет специальных действий.
    * `prod`: активируется вручную, использует **Maven Assembly Plugin** для сборки проекта в ZIP-архив.
* Запустить сборку с активацией профиля: `mvn package -P prod`.

**4. Интеграция с репозиторием артефактов**
* Для командной работы необходим централизованный репозиторий, например **Nexus** или **Artifactory**. В рамках лабораторной работы можно использовать **GitHub Packages**.
* В `pom.xml` добавить секцию `<distributionManagement>`, указывающую URL удаленного репозитория.
* Настроить аутентификацию в файле `~/.m2/settings.xml`.
* Выполнить команду `mvn deploy` для публикации артефактов в удаленный репозиторий.

---

## 6\. Отчеты и покрытие кода с помощью Jacoco

### **Теория**

**Покрытие кода** (code coverage) — это метрика, которая показывает, какая часть вашего кода была выполнена во время тестов. Плагин **JaCoCo** (Java Code Coverage) — один из самых популярных для этой задачи. Он создает детальные HTML-отчеты, где вы можете увидеть, какие строки кода были покрыты тестами, а какие — нет.

### **Пример**

Добавим плагин JaCoCo в секцию `<build><plugins>` в нашем `pom.xml`:

```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.jacoco</groupId>
            <artifactId>jacoco-maven-plugin</artifactId>
            <version>0.8.10</version>
            <executions>
                <execution>
                    <goals>
                        <goal>prepare-agent</goal>
                    </goals>
                </execution>
                <execution>
                    <id>report</id>
                    <phase>test</phase>
                    <goals>
                        <goal>report</goal>
                    </goals>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
```

Теперь, запустив `mvn test`, JaCoCo автоматически сгенерирует отчет. Его можно найти по пути `target/site/jacoco/index.html`. Откройте этот файл в браузере, чтобы увидеть подробный отчет о покрытии кода.

-----

## 7\. Сборка исполняемого файла с зависимостями (Shade Plugin)

### **Теория**

Когда вы собираете проект, `mvn package` создает JAR-файл, который не содержит сторонних зависимостей. Для создания "толстого" JAR (`fat jar`), который включает в себя все зависимости, можно использовать плагин **Maven Shade Plugin**. Это удобно, если вы хотите запустить приложение без необходимости управлять дополнительными библиотеками.

### **Пример**

Добавим Maven Shade Plugin в `pom.xml`. Укажем, какой класс является точкой входа (`main class`), чтобы JAR-файл был исполняемым.

```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-shade-plugin</artifactId>
            <version>3.5.1</version>
            <executions>
                <execution>
                    <phase>package</phase>
                    <goals>
                        <goal>shade</goal>
                    </goals>
                    <configuration>
                        <transformers>
                            <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
                                <mainClass>com.mycompany.lab2.Main</mainClass>
                            </transformer>
                        </transformers>
                    </configuration>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
```

Теперь, после выполнения `mvn package`, в директории `target` будет создан `fat jar` (например, `maven-lab-project-1.0-SNAPSHOT.jar`), который можно запустить командой: `java -jar target/maven-lab-project-1.0-SNAPSHOT.jar`.

-----

## 8\. Ручная сборка и выполнение

### **Инструкция**

1.  **Клонируйте** или создайте структуру проекта, описанную выше.
2.  **Заполните** файлы `pom.xml`, `StringUtils.java` и `StringUtilsTest.java`.
3.  **Откройте** терминал в корневой директории проекта.
4.  **Выполните** следующую последовательность команд, чтобы провести полную сборку:
      * `mvn clean`: Очистка директории `target` от предыдущих сборок.
      * `mvn package`: Выполняет компиляцию, тесты и создает JAR-файл.
5.  **Проверьте** результаты:
      * Проверьте отчеты Surefire в `target/surefire-reports`.
      * Откройте отчет JaCoCo (`target/site/jacoco/index.html`) в браузере.
      * Найдите исполняемый JAR-файл в `target` и попробуйте его запустить (если вы добавили `main class` и Shade Plugin).

-----

## 9\. Многомодульные проекты и профили (Дополнительно)

### **Теория**

  * **Многомодульные проекты** позволяют разделить большой проект на несколько подпроектов (`модулей`), каждый со своим `pom.xml`. Главный `pom.xml` (`parent pom`) управляет всеми модулями. Это помогает в организации кода и переиспользовании.
  * **Профили** (`profiles`) позволяют настраивать сборку для разных окружений (например, `dev`, `test`, `prod`). Вы можете активировать профиль с помощью команды `-P <имя_профиля>`.

### **Пример**

**Многомодульный проект:**

Главный `pom.xml` (в корневой директории):

```xml
<project>
    <packaging>pom</packaging>
    <modules>
        <module>core</module>
        <module>web</module>
    </modules>
</project>
```

Каждый модуль (`core`, `web`) будет иметь свою собственную директорию и свой `pom.xml`.

**Профили:**

Добавление профиля в `pom.xml`:

```xml
<profiles>
    <profile>
        <id>dev</id>
        <properties>
            <environment>development</environment>
        </properties>
        <build>
            </build>
    </profile>
</profiles>
```

Чтобы запустить сборку с этим профилем, используйте: `mvn package -P dev`.

## 10 Чтобы добавить **Maven** в уже существующий проект, нужно 
### Создание файла `pom.xml`

Создайте файл с именем `pom.xml` в корневой директории вашего проекта. Этот файл является "сердцем" Maven-проекта и содержит всю его конфигурацию.

### Заполнение базовой структуры

Добавьте в `pom.xml` базовую XML-структуру, которая включает в себя информацию о проекте:

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.mycompany.app</groupId>
    <artifactId>my-existing-app</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>jar</packaging>

    <properties>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
    </properties>

</project>
```

  * **`groupId`**: Уникальный идентификатор вашей компании или группы. Используйте обратный домен, например `com.mycompany.app`.
  * **`artifactId`**: Уникальное имя вашего проекта.
  * **`version`**: Текущая версия проекта.
  * **`packaging`**: Формат артефакта, который будет создан. Например, `jar` для исполняемого JAR-файла, `war` для веб-приложений.
  * **`properties`**: Определяют свойства, которые можно использовать по всему файлу. Здесь указываются версии JDK.

### Настройка каталогов

Maven использует стандартную структуру каталогов. Вам нужно будет привести структуру вашего проекта в соответствие с ней.

  * Исходный код Java: `src/main/java`
  * Ресурсы (файлы, не являющиеся кодом): `src/main/resources`
  * Исходный код тестов: `src/test/java`
  * Ресурсы тестов: `src/test/resources`

Если ваш проект имеет другую структуру, вы можете настроить её в `pom.xml`. Например:

```xml
<build>
    <sourceDirectory>src</sourceDirectory>
    <testSourceDirectory>test</testSourceDirectory>
</build>
```
### Сборка проекта

После того как `pom.xml` настроен, вы можете запустить сборку из командной строки, перейдя в корневую папку проекта.

```bash
mvn clean install
```

Эта команда очистит проект, скомпилирует его, запустит тесты, упакует в JAR и установит в локальный репозиторий. Если всё настроено правильно, Maven выполнит все шаги автоматически.

------

### Универсальные команды Maven

Эти команды работают в корневом каталоге любого проекта Maven, который содержит файл `pom.xml`.

---

#### 1. Сборка и установка проекта
* `mvn clean install`: **Очищает** директорию `target`, затем **компилирует** код, **запускает тесты** и **устанавливает** скомпилированный пакет (JAR/WAR) в ваш локальный репозиторий Maven. Это самая частая команда для полной сборки.

#### 2. Компиляция и тестирование
* `mvn compile`: **Компилирует** только исходный код. Полезно для быстрой проверки синтаксиса.
* `mvn test`: **Запускает** тесты. Этой командой можно быстро проверить, что все тесты проходят, без создания и установки пакета.

#### 3. Упаковка проекта
* `mvn package`: **Компилирует**, **запускает тесты** и **упаковывает** проект в JAR, WAR или другой тип архива. Файл создается в директории `target`.

#### 4. Просмотр зависимостей
* `mvn dependency:tree`: **Отображает** дерево зависимостей вашего проекта. Это очень полезно для поиска конфликтов версий или нежелательных зависимостей.

#### 5. Пропуск тестов
* `mvn clean install -DskipTests`: Выполняет полную сборку, но **пропускает** запуск тестов. Используется, когда нужно сэкономить время и вы уверены, что тесты пройдут.

---


### Часть 3. Основы Gradle (4 ч)

### Тема 2.3: Обзор Gradle, отличие от Maven, wrapper, конфигурирование проекта.
**Цель:** познакомиться с системой сборки **Gradle**, понять ее ключевые отличия от **Maven**, научиться создавать и настраивать **Gradle**-проекты, использовать **Gradle Wrapper** для воспроизводимости сборок.

## 1\. Обзор Gradle и Gradle Wrapper

### **Теория**

**Gradle** — это мощная система автоматизации сборки, основанная на Groovy и Kotlin DSL (Domain-Specific Language). В отличие от Maven, который использует XML, Gradle предлагает более гибкий и выразительный скриптовый подход.

**Gradle Wrapper** (`gradlew` или `gradlew.bat`) — это скрипт, который позволяет запускать сборку Gradle без предварительной установки самого Gradle. Он автоматически загружает нужную версию Gradle и обеспечивает согласованность сборок на разных машинах.

### **Пример**

Чтобы добавить Gradle Wrapper в ваш проект Maven, находясь в корневой директории, выполните команду:

```bash
gradle wrapper
```

Эта команда создаст следующие файлы и директории:

  * `gradlew` (для Linux/macOS)
  * `gradlew.bat` (для Windows)
  * `gradle/wrapper/gradle-wrapper.jar`
  * `gradle/wrapper/gradle-wrapper.properties`

Теперь для запуска любой задачи Gradle вы можете использовать `gradlew` вместо `gradle`.


#### Ход работы

**1. Установка и создание проекта**
* **Gradle** не требует глобальной установки, если используется **Gradle Wrapper**.
* Создать новый проект с помощью `gradle init`. Выбрать тип проекта (application), язык (Java), и DSL (Groovy или Kotlin). Для начала рекомендуется Groovy DSL.
    ```bash
    gradle init
    ```
* Изучить сгенерированную структуру:
    * `build.gradle`: основной скрипт сборки.
    * `settings.gradle`: определяет, какие проекты включены в сборку.
    * `gradlew` и `gradlew.bat`: скрипты **Gradle Wrapper**.

**2. Изучение build.gradle и управление зависимостями**
* Открыть файл `build.gradle` и изучить его структуру: блок `plugins`, `repositories`, `dependencies`.
* Сравнить его с `pom.xml` из **Maven**. **Gradle** использует декларативно-императивный подход на основе скриптового языка, что делает его более гибким.
* Добавить зависимость на **Google Guava**, как в части 1.
    ```groovy
    dependencies {
        // This dependency is used by the application.
        implementation 'com.google.guava:guava:31.1-jre'

        // Use JUnit Jupiter for testing.
        testImplementation 'org.junit.jupiter:junit-jupiter:5.8.1'
    }
    ```
* Обратить внимание на конфигурации зависимостей: `implementation` (зависимость видна только внутри модуля) и `api` (зависимость транзитивно передается другим модулям).

**4\. Задачи (Tasks) и Жизненный цикл**

### **Теория**

В Gradle все операции выполняются с помощью **задач** (`tasks`). Задачи могут быть созданы вами или предоставлены плагинами. Жизненный цикл сборки — это просто набор задач, которые выполняются в определенном порядке. Например, плагин `java` предоставляет стандартные задачи: `clean`, `compileJava`, `test`, `jar` и `build`.

### **Пример**

Чтобы выполнить задачу, используется команда `gradlew <task-name>`.

  * **Очистка проекта:** `gradlew clean`
  * **Компиляция кода:** `gradlew compileJava`
  * **Запуск тестов:** `gradlew test`
  * **Сборка исполняемого файла:** `gradlew build` (эта задача выполнит `clean`, `compile`, `test` и `jar` по порядку)

Вы можете посмотреть список всех доступных задач командой `gradlew tasks`.

* В **Gradle** основной единицей работы является `task` (задача).
* Фазы жизненного цикла **Maven** заменены графом зависимостей между задачами.
* Изучить основные задачи, предоставляемые плагином `java`:
	* `./gradlew build`: полная сборка проекта (компиляция, тесты, сборка JAR).
	* `./gradlew run`: запуск приложения.
	* `./gradlew clean`: удаление директории `build`.
	* `./gradlew test`: запуск тестов.
* Выполнить команду `./gradlew tasks --all`, чтобы увидеть все доступные задачи в проекте.

**4. Gradle Wrapper**
* **Gradle Wrapper** — это скрипт, который автоматически скачивает и использует указанную в проекте версию **Gradle**.
* Это гарантирует, что все разработчики и CI/CD-серверы используют одну и ту же версию, обеспечивая воспроизводимость сборки.
* Всегда использовать `./gradlew` (для Linux/macOS) или `gradlew.bat` (для Windows) вместо глобально установленного `gradle`.

---

## 2\. Конфигурирование Gradle-проекта (build.gradle)

### **Теория**

Основным файлом конфигурации в Gradle является `build.gradle` (или `build.gradle.kts` для Kotlin DSL). Этот файл описывает проект, его зависимости, плагины и задачи.

### **Пример**

Давайте создадим базовый `build.gradle` для нашего проекта, который ранее был на Maven.

**Файл: `build.gradle`**

```groovy
// Применяем плагины для Java и тестов
plugins {
    id 'java'
}

// Конфигурация репозиториев, где будут искаться зависимости
repositories {
    mavenCentral()
}

// Управление зависимостями
dependencies {
    // Зависимость для модульного тестирования
    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.10.0'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.10.0'

    // Зависимость для утилит Apache
    implementation 'org.apache.commons:commons-lang3:3.13.0'
}

// Конфигурация задач, например, для запуска тестов
test {
    useJUnitPlatform()
}
```

-----

## 3\. Зависимости в Gradle: Scopes

### **Теория**

В Gradle зависимости объявляются с помощью различных **scopes** (конфигураций). Это позволяет точно указать, когда и для чего нужна зависимость.

  * `implementation`: Зависимость, необходимая для компиляции и выполнения проекта. Она не видна для других проектов, зависящих от вашего. Это помогает ускорить инкрементальную сборку.
  * `api`: Зависимость, необходимая для компиляции и выполнения, которая также является частью публичного API вашего проекта. Она будет видна для проектов, которые от вас зависят.
  * `testImplementation`: Зависимость, необходимая только для компиляции и запуска тестов.

### **Пример**

В нашем `build.gradle` мы использовали:

  * `implementation 'org.apache.commons:commons-lang3:3.13.0'` — `commons-lang3` нужен для логики нашего приложения.
  * `testImplementation 'org.junit.jupiter:junit-jupiter-api:5.10.0'` — `junit` нужен только для тестов.



## Часть 4. Продвинутые возможности Gradle (4 ч)


## 4\. Инкрементальная сборка и кэширование

### **Теория**

Gradle спроектирован для **оптимизации скорости сборки**.

  * **Инкрементальная сборка:** Gradle отслеживает изменения в исходном коде и выполняет только те задачи, которые необходимы для обновления. Если вы ничего не меняли, Gradle пропустит эту задачу, помечая её как `UP-TO-DATE`.
  * **Кэш сборки:** Gradle может кэшировать результаты задач. Если задача с теми же входами (файлами, параметрами) была выполнена ранее (даже на другой машине), Gradle может использовать кэшированный результат, что значительно ускоряет повторные сборки.

### **Пример**

1.  **Выполните** полную сборку: `gradlew build`. Вы увидите, что все задачи выполняются.
2.  **Выполните** ту же команду снова: `gradlew build`. На этот раз Gradle покажет `UP-TO-DATE` для большинства задач, так как файлы не изменились.
3.  **Измените** один файл с исходным кодом.
4.  **Выполните** `gradlew build` ещё раз. Gradle заново скомпилирует только измененный файл и повторно выполнит зависящие от него задачи, в то время как остальные будут взяты из кэша.

-----

## 5\. Gradle для написания собственных задач

### **Теория**

Одним из главных преимуществ Gradle является возможность создавать собственные задачи. Это особенно полезно для автоматизации уникальных процессов, специфичных для вашего проекта.

### **Пример**

Добавим в наш `build.gradle` новую задачу, которая будет выводить приветствие.

```groovy
// ... (остальной код build.gradle)

task helloWorld {
    doLast {
        println "Привет, мир! Это моя первая задача Gradle."
    }
}
```

Теперь, чтобы выполнить эту задачу, достаточно ввести в терминале: `gradlew helloWorld`.

* В файле `build.gradle` создать собственную задачу (`task`), которая выводит приветственное сообщение.
    ```groovy
    task hello {
        doLast {
            println 'Hello, Gradle!'
        }
    }
    ```
* Запустить задачу: `./gradlew hello`.
* Создать более сложную задачу, которая копирует JAR-файл после его сборки в определенную директорию.
    ```groovy
    task copyJar(type: Copy) {
        from 'build/libs'
        into 'release'
    }
    // Указываем, что наша задача должна выполняться после задачи build
    copyJar.dependsOn build
    ```


## 6\. Ручная сборка и выполнение

### **Инструкция**

1.  **Создайте** проект с файлами `StringUtils.java` и `StringUtilsTest.java` (как в предыдущей работе).
2.  **Запустите** `gradle wrapper` в корневой директории проекта.
3.  **Создайте** файл `build.gradle` с конфигурацией, описанной в примерах.
4.  **Выполните** следующую последовательность команд, чтобы провести полную сборку:
      * `gradlew clean`
      * `gradlew build`
5.  **Проверьте** результаты:
      * Проверьте отчеты о тестах в директории `build/reports/tests/test/index.html`.
      * Найдите исполняемый JAR-файл в `build/libs`.

-----

## 7\. Kotlin DSL (build.gradle.kts) (Дополнительно)

### **Теория**

Kotlin DSL — это альтернатива Groovy для написания скриптов Gradle. Он обеспечивает лучшую автодополнение в IDE и строгую типизацию, что помогает избежать ошибок. Имена файлов с Kotlin DSL заканчиваются на `.kts`.

### **Пример**

Вот как выглядит наш `build.gradle` в формате Kotlin DSL:

**Файл: `build.gradle.kts`**

```kotlin
plugins {
    java
}

repositories {
    mavenCentral()
}

dependencies {
    testImplementation("org.junit.jupiter:junit-jupiter-api:5.10.0")
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine:5.10.0")

    implementation("org.apache.commons:commons-lang3:3.13.0")
}

tasks.test {
    useJUnitPlatform()
}
```

Команды для сборки остаются такими же, как и для Groovy DSL.


**2. Оптимизация сборки**
* **Gradle** предлагает мощные механизмы для ускорения сборок:
    * **Инкрементальная сборка:** **Gradle** анализирует входные и выходные данные задач. Если входные данные не изменились с последнего запуска, задача помечается как `UP-TO-DATE` и не выполняется повторно.
    * **Кэш сборки (Build Cache):** **Gradle** может кэшировать результаты выполнения задач. Если другой разработчик выполняет ту же задачу с теми же входными данными, результат может быть взят из общего кэша.
* Запустить `./gradlew build` несколько раз подряд и обратить внимание, что большинство задач будут иметь статус `UP-TO-DATE`.
* Включить кэширование сборки, добавив `org.gradle.caching=true` в файл `gradle.properties`.

**3. Многомодульный проект в Gradle**
* Аналогично части 2, создать многомодульный проект.
* В файле `settings.gradle` корневого проекта указать все подпроекты:
    ```groovy
    rootProject.name = 'parent-project'
    include 'core-module'
    include 'cli-module'
    ```
* В `build.gradle` модуля `cli-module` добавить зависимость на `core-module`:
    ```groovy
    dependencies {
        implementation project(':core-module')
    }
    ```
* Выполнить `./gradlew build` из корня проекта.

**4. Знакомство с Kotlin DSL**
* **Gradle** поддерживает написание билд-скриптов на **Kotlin** (`build.gradle.kts`).
* Это дает преимущества строгой типизации и автодополнения в IDE.
* Создать новый проект с помощью `gradle init` и выбрать **Kotlin** в качестве языка для скриптов сборки.
* Изучить синтаксис `build.gradle.kts`. Он очень похож на **Groovy DSL**, но со статическими типами.
    ```kotlin
    plugins {
        application
    }

    dependencies {
        implementation("com.google.guava:guava:31.1-jre")
    }
    ```
* Попробовать добавить зависимость и запустить сборку.

---

### Универсальные команды Gradle

Эти команды работают в корневом каталоге любого проекта Gradle, который содержит файлы `build.gradle` или `build.gradle.kts`.

---

#### 1. Сборка и тестирование
* `./gradlew clean build`: **Очищает** директорию `build` и выполняет **полную сборку**, включая компиляцию, запуск тестов и создание пакета. Если вы на Windows, используйте `gradlew clean build`.

#### 2. Запуск тестов
* `./gradlew test`: **Запускает** только тесты. Gradle покажет краткий отчет в консоли и сгенерирует подробный HTML-отчет в директории `build/reports/tests`.

#### 3. Просмотр задач
* `./gradlew tasks`: **Выводит** список всех доступных задач для вашего проекта. Это отличный способ узнать, какие операции вы можете выполнить.

#### 4. Просмотр зависимостей
* `./gradlew dependencies`: **Отображает** иерархию зависимостей для каждого набора исходников (например, `compileClasspath`, `testImplementation`). Очень полезно для отладки.

#### 5. Инкрементальная сборка
* `./gradlew build`: Повторный запуск этой команды — хороший способ увидеть силу инкрементальной сборки Gradle. Если вы не меняли код, большинство задач будут помечены как `UP-TO-DATE`, и сборка будет почти мгновенной.

### Отчёт по лабораторной работе должен содержать:

* Цель и задачи работы (общие и по каждой части).
* Краткое описание ПО, выбранного для реализации.
* Историю команд, использованных при выполнении каждой части работы (список команд и их назначение).
* Скриншоты ключевых этапов для **Maven** и **Gradle**:
    * Структура проекта после генерации.
    * Фрагменты `pom.xml` / `build.gradle` с добавленными зависимостями и плагинами.
    * Вывод консоли после выполнения ключевых фаз/задач (`mvn package`, `mvn deploy`, `./gradlew build`).
    * Структура многомодульного проекта.
    * Пример создания собственной задачи в **Gradle**.
* Ссылку на удалённый **Git**-репозиторий, содержащий два проекта: один собранный с помощью **Maven**, другой — с помощью **Gradle**.

---

#### **Варианты**
*Для выполнения этой лабораторной работы используется проект, разработанный в рамках лабораторной работы №1.*
