**Инструменты поддержки промышленной разработки программного обеспечения**
## Лабораторная работа №2 (6 ч)

**Тема:** Системы сборки ПО. Maven и Gradle.

**Цель работы:** изучить принципы работы и возможности современных систем автоматической сборки на примере Maven и Gradle. Освоить практические навыки по созданию и управлению проектами, управлению зависимостями, жизненным циклом сборки, а также познакомиться с техниками, такими как многомодульные проекты, профили сборки и оптимизация производительности.

### Задание и теоретические сведения

Работу с системами сборки осуществлять преимущественно через CLI (консоль).

В процессе выполнения работы использовать систему контроля версий. Каждый этап задания фиксируйте коммитом.

#### Maven. Основы и жизненный цикл

*Maven* - это система управления проектами и автоматизации сборки, основанная на декларативном подходе. Она использует файл конфигурации `pom.xml`, в котором описываются зависимости, плагины, фазы сборки и прочие параметры проекта. Благодаря строгой структуре и предсказуемому жизненному циклу, Maven обеспечивает стандартизированную организацию проектов, что упрощает сопровождение и интеграцию в корпоративные процессы. 

Он позволяет автоматически загружать и обновлять библиотеки из центральных репозиториев, управлять многомодульными проектами, запускать тесты, собирать артефакты и публиковать их в репозитории. *Maven* широко применяется в промышленной разработке благодаря своей стабильности, богатой экосистеме плагинов и удобной интеграции с *IDE* и системами непрерывной интеграции.

##### Подготовка и создание проекта

Установите [Apache Maven](https://maven.apache.org/download.cgi) и убедитесь, что он доступен из командной строки (`mvn -v`). 

Создайте новый Maven-проект с помощью **архетипа** - шаблона проекта. Для простого консольного приложения на Java используйте архетип `maven-archetype-quickstart`.

```bash
mvn archetype:generate -DgroupId=by.gstu.project -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false
```

Необходимые параметры:
- `-DgroupId` - идентификатор компании или организации (например, `by.gstu.project`)
- `-DartifactId` - имя артефакта, т.е. проекта (например, `my-app`)
- `-DarchetypeArtifactId` - идентификатор архетипа (`maven-archetype-quickstart`)
- `-DinteractiveMode` - отключение интерактивного режима (`false`)

Изучите структуру созданного проекта:
- исходный код Java: `src/main/java`
- ресурсы (файлы, не являющиеся кодом): `src/main/resources`
- исходный код тестов: `src/test/java`
- ресурсы тестов: `src/test/resources`
- файл-дескриптора: `pom.xml`

Откройте файл `pom.xml` (Project Object Model) и изучите его структуру:
* `groupId` - идентификатор вашей компании или организации (например, `by.gstu.project`)
* `artifactId` - идентификатор конкретного проекта (например, `my-app`)
* `version` - версия проекта (например, `1.0-SNAPSHOT`)
* `packaging` - формат артефакта, который будет создан. Например, `jar` для исполняемого JAR-файла, `war` для веб-приложений
* `properties` - определяют свойства, которые можно использовать по всему файлу. Здесь указываются версии JDK.

##### Зависимости

Maven автоматически загружает и управляет библиотеками, необходимыми для вашего проекта. Для добавления библиотеки к проекту необходимо в файле `pom.xml` в секции `<dependencies>` указать `groupId`, `artifactId` и `version` нужной зависимости. Maven загрузит их из [центрального репозитория](https://mvnrepository.com/) (Maven Central).

Добавьте библиотеку для тестирования `JUnit 5` и библиотеку для вывода цветного текста в консоль `JANSI`. Для этого найдите в репозитории Maven Central библиотеку JUnit 5. Добавьте зависимость в `pom.xml` внутри секции `<dependencies>`.

```xml
<!-- https://mvnrepository.com/artifact/junit/junit -->
<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <version>4.13.2</version>
    <scope>test</scope>
</dependency>

<!-- https://mvnrepository.com/artifact/org.fusesource.jansi/jansi -->
<dependency>
	<groupId>org.fusesource.jansi</groupId>
	<artifactId>jansi</artifactId>
	<version>2.4.2</version>
	<scope>compile</scope>
</dependency>
```

Выполните команду `mvn dependency:resolve`, чтобы Maven скачал указанную библиотеку и ее транзитивные зависимости. Проверьте локальный репозиторий (`~/.m2/repository`).

##### Жизненный цикл сборки

Жизненный цикл Maven состоит из ряда фаз, которые выполняются последовательно. Основные фазы:
* `validate` - проверяет корректность информации о проекте
* `compile` - компилирует исходный код проекта
* `test` - запускает тесты с использованием подходящего фреймворка
* `package` - упаковывает скомпилированный код в архив, например, JAR
* `install` - устанавливает пакет в локальный репозиторий для использования в качестве зависимости в других проектах
* `deploy` - копирует финальный артефакт в удаленный репозиторий

Для запуска фазы необходимо выполнить команду `mvn <название_фазы>`.

Выполните последовательно следующие команды:
  * компиляция кода: `mvn compile`
  * запуск тестов: `mvn test`
  * сборка пакета: `mvn package`
  * установка в локальный репозиторий: `mvn install`

Обратите внимание, что запуск любой фазы автоматически вызывает все предыдущие фазы.

Дополнительные команды:
- очистка собранных файлов (папка `target`): `mvn clean`
- отображение дерева зависимостей: `mvn dependency:tree`
- пропуск тестов: `mvn clean install -DskipTests`

##### По проекту

Переместите файлы Java-классов, разработанных в л.р. №1, в созданный проект. Разработайте модульные тесты.

*Примечание: можно использовать свой проект.*

#### Плагины, многомодульные проекты, профили, интеграция с репозиторием в Maven

##### Плагины

Плагины - это сердце Maven. Они выполняют конкретные задачи во время сборки. **Surefire** - один из самых важных. Он запускает тесты и создает отчеты. Эти отчеты позволяют увидеть какие тесты прошли успешно, а какие нет.

Добавьте в `pom.xml` этот плагин:

```xml
<build>
  <plugins>
	<plugin>
	  <artifactId>maven-surefire-plugin</artifactId>
	  <version>2.22.2</version>
	</plugin>
  </plugins>
</build>
```

После выполнения `mvn test` перейдите в директорию `target/surefire-reports`. В ней содержатся XML и текстовые файлы с результатами тестов.

Чтобы получить более читаемый отчет, можно использовать плагин **Maven Site**, который генерирует целый сайт проекта.

##### Сборка исполняемого файла с зависимостями

Когда Вы собираете проект, команда `mvn package` создает *JAR*-файл, который не содержит сторонних зависимостей. Для создания "толстого" *JAR* (*fat JAR*), который включает в себя все зависимости, можно использовать плагин **Shade Plugin**.

Добавьте **Shade Plugin**. Укажите, какой класс является точкой входа (класс, содержащий функцию `main`), чтобы *JAR*-файл был исполняемым.

```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-shade-plugin</artifactId>
            <version>3.5.1</version>
            <executions>
                <execution>
                    <phase>package</phase>
                    <goals>
                        <goal>shade</goal>
                    </goals>
                    <configuration>
                        <transformers>
                            <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
                                <mainClass>com.mycompany.lab2.Main</mainClass>
                            </transformer>
                        </transformers>
                    </configuration>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
```

Выполните команду `mvn package`. В результате в папке `target` будет создан fat-jar `<название>.jar`, который можно запустить командой `java -jar <название>.jar`. 

*Примечание: если fat-JAR не создался, то проверьте не обвернуты ли плагины в pom.xml тегом pluginManagement. Если да, то удалите этот тег.*

##### Создание многомодульного проекта

Многомодульные проекты позволяют разделить большой проект на несколько подпроектов (модулей), каждый со своим `pom.xml`. Главный `pom.xml` (*parent pom*) управляет всеми модулями. Такая структура позволяет разделять код на логические части (например, `api`, `service`, `CLI`) и повторно использовать модули в разных проектах.

В родительском `pom.xml` (который уже существует) добавьте тип упаковки `<packaging>pom</packaging>` - обозначает, что родительский проект управляет модулями и зависимостями:

```XML
<project>
  ...

  <packaging>pom</packaging>

  <!-- Список модулей -->
  <modules>
    <module>module-core</module>
    <module>module-cli</module>
  </modules>

  <!-- Здесь Вы можете указать общие зависимости для всех модулей,
       но они не будут активными. Если какая-либо зависимость нужна
	   в модуле, то необходимо указать ее в pom.xml модуля. Здесь
	   Вы только объявляете эту зависимость и указываете для нее
	   необходимые параметры -->
  <dependencyManagement>
    <dependencies>        
      <dependency>
		...
	  </dependency>
	</dependencies>
  </dependencyManagement>

  <!-- Аналогично и для плагинов -->
  <pluginManagement>
    <plugins>
	  <plugin>
	    ...
	  </plugin>
	</plugins>
  </pluginManagement>
  
  ...
</project>
```

Далее создайте два модуля:
* `module-core` (бизнес-логика)
* `module-cli` (консольный интерфейс, зависит от `module-core`)

Сделать это можно с помощью команды для генерации проекта. Дополнительно рекомендуется задать самостоятельно `package` для модуля с помощью флага `Dpackage`, чтобы в нем не присутствовало слово `module`:

```Shell
mvn archetype:generate -DgroupId=by.gstu.project -DartifactId=module-core -Dpackage=by.gstu.project.core -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false
```

Обратите внимание на изменения в родительском `pom.xml`. *Maven* автоматически добавит в него список созданных модулей:

```XML
<modules>
  <module>module-core</module>
  <module>module-cli</module>
</modules>
```

Также обратите внимание, что в `pom.xml` модулей есть ссылка на родительский проект.

```XML
<parent>
  <groupId>by.gstu.project</groupId>
  <artifactId>my-app</artifactId>
  <version>1.0-SNAPSHOT</version>
</parent>
```

Добавьте в `pom.xml` модулей тип упаковки: `<packaging>jar</packaging>` - обозначает, что модуль должен быть собран в *Java*-библиотеку (*JAR*-файл).

В `module-cli` добавьте зависимость на `module-core`:

```XML
<dependency>
  <groupId>by.gstu.project</groupId>
  <artifactId>module-core</artifactId>
  <version>1.0-SNAPSHOT</version>
</dependency>
```

Разделите проект, разработанный в л.р. №1, на две части:
- классы бизнес-логики перенесите в `module-core`
- классы *UI* перенесите в `module-cli`

При этом в родительском проекте удалите папки с исходным кодом (`src`). Т.е. в родительском проекте должны быть только папки `module-cli`, `module-core` и файл `pom.xml`.

Добавьте **Shade Plugin** в модуль `module-cli`. Выполните `mvn package` из родительской директории. *Maven* автоматически определит порядок сборки модулей. Перейдите в папку `module-cli/target` и запустите *fat JAR*.

##### Профили сборки

**Профили** (`profiles`) позволяют настраивать сборку для разных окружений (например, `dev`, `test`, `prod`). **Профиль** можно активировать с помощью флага `-P<имя_профиля>`.

В родительском `pom.xml` создайте два профиля:
* `dev`: активируется по умолчанию, не выполняет специальных действий.
* `prod`: активируется вручную, использует **Assembly Plugin** для сборки проекта в *fat JAR*

```xml
<project>
  ...

  <profiles>
    <profile>
      <id>dev</id>
      <activation>
        <activeByDefault>true</activeByDefault>
      </activation>
    </profile>

    <profile>
      <id>prod</id>
      <build>
        <plugins>
          <plugin>
            <artifactId>maven-assembly-plugin</artifactId>
            <version>3.7.1</version>
            <configuration>
              <descriptorRefs>
                <descriptorRef>jar-with-dependencies</descriptorRef>
              </descriptorRefs>
              <archive>
                <manifest>
                  <mainClass>by.gstu.project.cli.App</mainClass>
                </manifest>
              </archive>
              <finalName>${project.artifactId}-prod</finalName>
            </configuration>
            <executions>
              <execution>
                <id>make-assembly</id>
                <phase>package</phase>
                <goals>
                  <goal>single</goal>
                </goals>
              </execution>
            </executions>
          </plugin>
        </plugins>
      </build>
    </profile>
  </profiles>
  
...
</project>
```

Запустите сборку с активацией профиля: `mvn package -Pprod`. В результате в папке `module-cli/target` Вы увидите `.jar` файл с названием `<название_проекта>-prod-jar-with-dependencies`.

##### Отчеты и покрытие кода с помощью Jacoco

Покрытие кода (*code coverage*) - это метрика, которая показывает, какая часть вашего кода была выполнена во время тестов. Плагин *JaCoCo* (*Java Code Coverage*) - один из самых популярных для этой задачи. Он создает детальные *HTML*-отчеты, где вы можете увидеть, какие строки кода были покрыты тестами, а какие нет.

Добавьте плагин *JaCoCo*:

```xml
<build>
  <plugin>
	<groupId>org.jacoco</groupId>
	<artifactId>jacoco-maven-plugin</artifactId>
    <version>0.8.10</version>
  <executions>
	<execution>
	  <goals>
		<goal>prepare-agent</goal>
	  </goals>
	</execution>
	<execution>
		<id>report</id>
		<phase>test</phase>
		<goals>
		  <goal>report</goal>
	    </goals>
	  </execution>
    </executions>
  </plugin>
</build>
```

Теперь, запустив `mvn test`, *JaCoCo* автоматически сгенерирует отчет. Его можно найти по пути `target/site/jacoco/index.html`. Откройте этот файл в браузере, чтобы увидеть подробный отчет о покрытии кода.
#### Gradle. Основы и жизненный цикл

**Gradle** - это современная система автоматизации сборки, которая используется для компиляции, тестирования, упаковки и развертывания программных проектов на *Java*, *Kotlin*, *Android* и др. Она основана на декларативных скриптах *Groovy* и *Kotlin DSL* (*Domain-Specific Language*) и сочетает в себе гибкость скриптового подхода с производительностью благодаря кэшированию и инкрементным сборкам. 

*Gradle* позволяет управлять зависимостями, создавать собственные задачи, работать с многомодульными проектами и легко интегрироваться в процессы *CI/CD*. В отличие от *Maven*, который использует строгую *XML*-конфигурацию и делает ставку на стандартизацию и предсказуемость, *Gradle* предоставляет больше свободы и возможностей для кастомизации, а также значительно выигрывает в скорости сборки.

##### Подготовка и создание проекта

Установите [Gradle](https://gradle.org/) и убедитесь, что он доступен из командной строки (`gradle -v`).

Для создания проекта выполните следующую команду:

```bash
gradle init --dsl kotlin
```

Gradle попросит указать следующие параметры:
- тип проекта (указываем `Application`)
- ЯП (указываем `Java`)
- версия *Java* (указываете версию установленной у Вас *Java*)
- название проекта
- структура проекта (указываем `Single application project`)
- фреймворк для тестирования

Изучите структуру созданного проекта.

##### Добавление зависимостей

Добавление зависимостей в проект выполняется в файле `app/build.gradle.kts`. Убедитесь для начала, что в файле указан репозиторий, откуда Gradle будет скачивать зависимости (в данном случае, *Maven Central*):

```Kotlin
repositories {
    mavenCentral()
}
```

Добавьте зависимость **JANSI**:

```Kotlin
dependencies {
    // https://mvnrepository.com/artifact/org.fusesource.jansi/jansi
    implementation("org.fusesource.jansi:jansi:2.4.2")
}
```

Перенесите исходный код из проекта на Maven. Проверьте, что в `build.gradle.kts` верно указан класс, который является точкой старта приложения:

```Kotlin
application {
    mainClass = "by.gstu.project.App"
}
```

Выполните сборку и запуск проекта:

```bash
gradle build run
```

##### Задачи (Tasks) и жизненный цикл

В Gradle все операции выполняются с помощью **задач** (tasks). Задачи могут быть созданы Вами или предоставлены плагинами. Gradle уже содержит встроенные задачи (например, `build`, `run`, `clean`).

Жизненный цикл сборки - это просто набор задач, которые выполняются в определенном порядке. Например, плагин `java` предоставляет стандартные задачи: `clean`, `compileJava`, `test`, `jar` и `build`.

Для просмотра списка задач можно выполнить следующую команду:

```bash
gradle tasks
```

Создать свою задачу можно в файле `build.gradle.kts`:

```Kotlin
tasks.register("my-task") {
    doLast {
        println("This is my task")
    }
}
```

Создайте и выполните свою задачу.

##### Создание многомодульного проекта

Организуйте структуру проекта так же, как и в проекте с Maven (два модуля: `module-cli` и `module-core`). Создайте в папках модулей и в корневой папке файл `build.gradle.kts`.

В файле `build.gradle.kts` модуля `module-core` напишите следующую конфигурацию:

```Kotlin
plugins {
    java
}

dependencies {
    testImplementation(libs.junit)
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}
```

В файле `build.gradle.kts` модуля `module-cli`:

```Kotlin
plugins {
    // Подключаем плагин application, чтобы этот модуль был исполняемым
    application
}

dependencies {
    implementation(libs.guava)

    // https://mvnrepository.com/artifact/org.fusesource.jansi/jansi
    implementation("org.fusesource.jansi:jansi:2.4.2")

	// Зависимость от модуля module-core
    implementation(project(":module-core"))
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

application {
    mainClass = "by.gstu.project.cli.App"
}
```

В файле `build.gradle.kts` в корневой папке укажем общий параметр для всех модулей, а именно репозиторий зависимостей:

```Kotlin
// В этой секции можно указать общие параметры для всех модулей
allprojects {
	repositories {
	    mavenCentral()
	}
}
```

Также в файле `setting.gradle.kts` (в корневой папке) необходимо подключить созданные модули. Для этого добавьте в файл следующее:

```Kotlin
include("module-core", "module-cli")
```

Соберите проект с помощью задачи `build`. Запустите с помощью следующей команды:

```bash
gradle :module-cli:run
```

В этой команде необходимо указать название модуля, в котором находится точка запуска приложения, а также указать название задачи для запуска (т.е. `run`).

##### Инкрементальная сборка

Попробуйте не изменяя проект выполнить повторную сборку. Обратите внимание, что в таком случае сборка выполняется гораздо быстрее.

Суть заключается в том, что в Gradle сборка инкрементальная, т.е. Gradle выполняет только те задачи, которые действительно нуждаются в повторном выполнении. Он избегает ненужной работы, если результат уже был получен ранее и входные данные не изменились. Gradle отслеживает:
- входные файлы (например, исходный код, ресурсы)
- выходные файлы (например, .class, .jar)
- параметры задачи

Если ничего не изменилось - задача пропускается.

##### Gradle Wrapper

Gradle Wrapper - это скрипт, который автоматически скачивает и использует указанную в проекте версию Gradle. Это гарантирует, что все разработчики и CI/CD-серверы используют одну и ту же версию, обеспечивая воспроизводимость сборки.

Например, если необходимо выполнить сборку и запуск проекта на другой машине, на которой не установлен Gradle (или установлен, но другой версии), то рекомендуется использовать `gradlew`. Скрипт `gradlew` всегда создается автоматически при создании проекта.

Небольшое пояснение: `gradlew` используется вместо `gradle`, например, для сборки проекта вместо команды `gradle build` необходимо выполнить команду `./gradlew build`.

Попробуйте выполнить команду `./gradlew build`. Начнется загрузка Gradle версии, укаанной в файле `gradle/wrapper/gradle-wrapper.properties`. Отмените ее комбинацией клавиш `Ctrl+C`.

### Отчет по лабораторной работе должен содержать

1. Цель работы.
2. Краткое описание ПО, выбранного для реализации.
3. Историю команд, использованных при выполнении каждой части работы (список команд и их назначение).
4. Скриншоты ключевых этапов для **Maven** и **Gradle**:
    1. Структура проекта после генерации.
    2. Фрагменты `pom.xml` / `build.gradle` с добавленными зависимостями и плагинами.
    3. Вывод консоли после выполнения ключевых фаз/задач.
    4. Структура многомодульного проекта.
    5. Пример создания собственной задачи в **Gradle**.
5. Ссылку на удалённый **Git**-репозиторий, содержащий два проекта: один собранный с помощью **Maven**, другой - с помощью **Gradle** (в разных ветках).

### Список вопросов на защиту

1. Какой файл используется для конфигурации проекта в Maven?
2. Какой файл используется для конфигурации проекта в Gradle?
3. Какой командой можно создать новый Maven-проект?
4. Какой командой можно создать новый Gradle-проект?
5. В каком разделе файла pom.xml указываются зависимости?
6. Какой командой можно запустить задачу в Gradle?
7. Какой командой можно собрать проект в Maven?
8. Что такое Gradle Wrapper?
9. Какой командой можно использовать Gradle Wrapper для сборки проекта?
10. Жизненный цикл сборки в Maven?
11. Как добавить зависимость в Gradle?
12. Что такое инкрементальная сборка в Gradle?
13. Как создать собственную задачу в Gradle?
14. Как создать профиль сборки в Maven?
15. Что такое модульный проект в контексте Maven и Gradle?