**Инструменты поддержки промышленной разработки программного обеспечения**
## Лабораторная работа №3 (8 ч)

**Тема:** Автоматизация сборки, тестирования и развертывания программного обеспечения в системе CI/CD.

**Цель работы:** Освоить базовые принципы CI/CD и их роль в промышленной разработке ПО. Получить практические навыки настройки автоматизированной сборки, тестирования и развертывания Java-проекта в системе CI/CD.

### Теоретические сведения

#### Что такое CI/CD

Непрерывная интеграция (Continuous Integration, CI) и непрерывная доставка (Continuous Delivery, CD) представляют собой набор принципов и практик, которые позволяют разработчикам чаще и надежнее развертывать изменения программного обеспечения.

Непрерывная интеграция (CI) - это автоматическая интеграция кода в репозиторий проекта. Цель CI - упростдить объединение кода от разных разработчиков и быстро выявлять ошибки. Когда программист отправляет код в репозиторий, система запускает тесты.

Непрерывная доставка и развертывание (CD) обеспечивают автоматическую подготовку и доставку приложения в рабочее или тестовое окружение. 

CI/CD помогает быстрее выпускать новые версии программы, не тратя время на ручную сборку и развертывание, а значит - меньше ошибок и больше скорости в разработке.

CI/CD можно объяснить очень просто. Представьте, что у вас есть проект, над которым работает команда. Каждый пишет свой кусочек кода, и нужно, чтобы все это вместе работало без ошибок. CI - это когда кто-то добавляет изменения в репозиторий и автоматически запускается проверка: собирается проект, выполняются тесты, и сразу видно, не сломалось ли что-то. CD - это следующий шаг: после успешной проверки приложение автоматически упаковывается и отправляется на рабочий или тестовый сервер/облако, с которого приложение доступно пользователям.

##### CI/CD Pipeline

CI/CD pipeline (расшифровывается как «конвейер непрерывной интеграции и непрерывного развертывания») - это автоматизированная последовательность этапов, через которую проходит программный код от момента внесения изменений до его развертывания в рабочей среде.

Этапы CI/CD пайплайна различаются в зависимости от продукта и конкретной команды разработчиков, но общие черты всегда одинаковые - есть некая стандартная последовательность действий, которая выполняется практически в любом пайплайне.

Чаще всего пайплайн можно представить в виде 6 основных шагов:
1. **Триггер.** Пайплайн должен запускаться автоматически каждый раз, когда фиксируется отправка нового кода в репозиторий (например, при `push` в ветку `prod` или при создании тега с версией проекта).
2. **Проверка кода.** Инструмент CI/CD извлекает код из репозитория. На этой стадии могут быть запущены инструменты статического анализа кода, останавливающие выполнения пайплайна в случае выявления ошибки.
3. **Компиляция кода.** Очевидно, инструмент CI/CD должен иметь доступ ко всем инструментам сборки, которые необходимы для компиляции кода. Например, если приложение написано на Java, то могут использоваться Maven или Gradle.
4. **Unit-тестирование.** Важнейший элемент пайплайна - модульное тестирование или unit testing. Скомпилированное приложение запускается с использованием тестов, если выполнение завершается без ошибки, значит можно переходить к следующему этапу пайплайна. Важно обеспечить максимальное покрытие тестами всех функций и компонентов приложения. При этом тесты должны поддерживаться и улучшаться по мере роста кодовой базы.
5. **Упаковка кода.** Если все тесты пройдены, то перед доставкой пользователю приложение нужно упаковать в конечный build. Например, если код на Java, то создается JAR-файл.
6. **Доставка и развертывание.** На этом этапе уже существует готовый к развертыванию программный продукт, которые необходимо доставить в рабочую среду клиента и корректно его установить. Для непрерывного развертывания нужна производственная среда. Например, это может быть публичное облако со своим собственным API.

#### GitHub Actions

GitHub Actions - это встроенная в GitHub платформа автоматизации, которая позволяет запускать рабочие процессы при наступлении событий в репозитории. По сути, это оркестратор задач, который реагирует на изменения кода и выполняет набор шагов: сборку, тестирование, упаковку артефактов и развертывание.

##### Кратко о возможностях и типовых сценариях

GitHub Actions предоставляет хостируемые виртуальные машины с предустановленными инструментами, кэширование зависимостей, секреты и переменные окружения, хранение артефактов и тонкую оркестрацию шагов. 

В контексте Java-проекта с Gradle это означает возможность автоматически запускать wrapper-скрипт, прогонять юнит-тесты, собирать jar/war, а затем деплоить на целевую платформу.

Сердцем этой автоматизации является workflow-файл.

##### Что такое Workflow-файл

Workflow описывается в YAML-файле (`.yml` или `.yaml`) внутри каталога `.github/workflows`. В этом файле вы описываете, что нужно сделать и когда это нужно сделать, т.е. описываете CI/CD pipeline. Например: когда кто-то делает `push` в ветку `main`, что нужно сделать: взять код из репозитория, установить Java, запустить команду `./gradlew build`.

Ниже представлен пример workflow-файла:

```YAML
# .github/workflows/build.yml

# 1. Название Workflow
name: Java CI with Gradle

# 2. Триггер: запускать при push в ветку main
on:
  push:
    branches: [ "main" ]

# 3. Работы (задания)
jobs:
  # 4. Название работы (job_id) - "build"
  build:

    # 5. На какой ОС запускать
    runs-on: ubuntu-latest

    # 6. Шаги, которые нужно выполнить
    steps:
      # 7. Шаг 1: "uses" - скачать код репозитория
      - name: Checkout repository
        uses: actions/checkout@v4

      # 8. Шаг 2: "uses" - установить Java (JDK 17)
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin' # Популярный дистрибутив Java

      # 9. Шаг 3: "run" - даем права на выполнение Gradle-скрипту
      - name: Grant execute permission for gradlew
        run: chmod +x gradlew

      # 10. Шаг 4: "run" - запускаем сборку и тесты
      - name: Build with Gradle
        run: ./gradlew build
```

Разберем подробнее ключевые блоки:
- `name` - название вашего workflow. Оно будет отображаться во вкладке Actions в GitHub
- `on` - событие, при наступлении которого запускается workflow
- `jobs` - контейнер для всех работ (заданий), которые нужно выполнить
	- `<job_id>` - название работы (например, `build`)
	- `runs-on` - виртуальная машина (ОС), на котором будут выполняться задачи. GitHub предоставляет их бесплатно
	- `steps` - последовательность шагов (команд), которые нужно выполнить
		- каждый шаг начинается с символа `-`
		- `uses` - использует готовое действие (Action), созданное сообществом или GitHub. Это похоже импорт библиотеки
		- `run` - выполняет команду в командной строке (shell) виртуальной машины

##### Создание Workflow-файла

1. Зайдите в репозиторий на GitHub.
2. Нажмите на вкладку **Actions** (она находится рядом с **Code**, **Issues**, **Pull Requests**).
3. GitHub проанализирует код и, увидев Java/Gradle, сам предложит шаблон.
4. Найдите карточку **Java with Gradle** и нажмите **Configure**.
5. GitHub откроет редактор и создаст файл `.yml` с уже готовым кодом. *Примечание:* GitHub-шаблон может быть сложнее, чем нужно. Вы можете полностью удалить его содержимое и вставить пример, который приведен выше, чтобы лучше понять основы.
6. Когда закончите редактирование, нажмите на кнопку **Commit changes**.
7. Готово! Workflow-файл сохранен в `.github/workflows/`. Перейдите снова на вкладку **Actions** - Вы увидите, как ваш первый workflow уже запущен.

##### Дополнительные возможности

Workflow-файл - это только начало. В **Actions** можно найти другие инструменты:
- **просмотр логов**: Вы можете кликнуть на любой запущенный workflow и посмотреть детальные логи каждого шага. Если сборка или тесты "упали" (failed), Вы увидите красный крестик и сможете прочитать ошибку прямо в логах
- **секреты (Secrets):** если Вам нужно использовать секретные данные (пароль от базы данных, API-ключ) или передать приложению файл конфигурации, их нельзя писать в YAML-файл. Вы можете сохранить их в **Settings -> Secrets and variables -> Actions**. Они будут безопасно переданы в workflow
- **Артефакты (Artifacts):** после шага `./gradlew build` появляется `.jar` файл. Но виртуальная машина удаляется после выполнения. Чтобы сохранить этот `.jar`, Вы можете добавить шаг `actions/upload-artifact` в workflow-файл. Это позволит скачать собранное приложение прямо со страницы workflow
- **Матрица сборок (Matrix builds):** используется для сборки одного и того же кода с разными параметрами, например, на разных JDK (например, Java 8, 11 и 17) или на разных ОС (например, Ubuntu и Windows)

<p align="center">
  <img src="media/dev-ops-senior.gif" alt="Dev-ops"/>
</p>

### Задание

Разработать Java-приложение согласно варианта (по списку в журнале) со сборщиком Gradle. Настроить GitHub Actions workflow для автоматической сборки проекта, запуска тестов и других действий согласно варианта.

**Требования к ПО:**
- код должен быть логически разделен на классы и пакеты
	- приложение должно быть расширяемым и легко изменяемым. Вы должны за короткое время по требованию преподавателя внести изменения в приложение
- весь код бизнес-логики должен быть задокументирован с использованием JavaDoc
- весь код бизнес-логики должен быть покрыт тестами

**Общие требования:**
- использовать Git согласно методике, описанной в л.р. №1 (т.е. использовать ветки, поддерживать версионность, описывать изменения)
	- если нет должной истории проекта или временной промежуток между начальной и конечной версии проекта слишком короткий, то л.р. считается невыполненной
	- в истории коммитов в поле "автор" должны быть указаны Ваши фамилия и имя
	- настроить корректно файл `.gitignore`, чтобы в репозитории были только лишь файлы с исходным кодом и `gradlew`. Также необходимо игнорировать файл конфигурации приложения (`app.properties`)
- к проекту должна быть полная и понятная документация по сборке и запуску
	- для проектов предложенных вариантов рекомендуется составлять документацию со следующей структурой:
		- краткое описание проекта: что делает, для чего нужен, на каких технологиях реализован
		- пример работы (что подается на вход и что выводит)
		- как выполнить сборку проекта
		- как выполнить конфигурацию проекта (должно быть описано содержимое файла `app.properties` и варианты настройки параметров)
		- как запустить тесты и какой результат ожидать
		- как запустить приложение

### Варианты

#### 1. Анализатор логов Nginx

**Описание:** Приложение парсит файлы `access.log` (в стандартном формате Nginx) для извлечения статистики.

**Функционал**:
- Чтение лог-файла, путь к которому указан в `app.properties`
- **Задание 1 (Поиск):** найти 10 IP-адресов, с которых было совершено больше всего запросов
- **Задание 2 (Агрегация):** подсчитать общее количество запросов по кодам ответа (200, 404, 501 и т.д.) и вывести статистику
- **Задание 3 (Фильтрация):** найти все запросы, пришедшие от определенного User-Agent (задается в `app.properties`)

**Формат входных данных:** стандартный Nginx `access.log` (генерируемый или реальный)

```txt
192.168.1.1 - - [10/Nov/2025:10:00:00 +0100] "GET /index.html HTTP/1.1" 200 1234 "-" "Mozilla/5.0..."
192.168.1.2 - - [10/Nov/2025:10:00:01 +0100] "GET /api/user HTTP/1.1" 404 150 "-" "curl/7.68.0"
...
```

**Формат выходных данных:** JSON-отчет в `stdout` или в файл (зависит от конфигурации)

```JSON
{
  "top_ips": [
    {"ip": "192.168.1.1", "count": 50},
    {"ip": "192.168.1.2", "count": 30}
  ],
  "status_codes": {
    "200": 50,
    "404": 30
  },
  "user_agent_hits": 15
}
```

**Пример файла конфигурации:** (`app.properties`)

```Properties
# Путь к лог-файлу
log.file.path=./data/access.log
# Количество IP-адресов для топа
report.top.ip.count=10
# User-Agent для поиска
filter.user.agent=curl/7.68.0
# Тип вывода: STDOUT или FILE
output.target=STDOUT
```

**Доп. задачи к CI/CD**:
- **Сборка на разных ОС:** настроить `matrix` для сборки на `ubuntu-latest`, `windows-latest` и `macos-latest`
- **Статический анализ:** добавить шаг для запуска плагина `checkstyleMain` на проверку покрытия всех методов автодокументацией JavaDoc. Сборка должна падать, если анализ не пройден
- **Кэширование:** настроить `actions/cache` для кэширования зависимостей Gradle (папки `.gradle/caches` и `.gradle/wrapper`) для ускорения последующих сборок

#### 2. Утилита "Пинг-монитор"

**Описание:** Java-приложение, которое читает список хостов (IP-адресов или доменных имен) из файла, выполняет для каждого системную команду `ping` и парсит ее вывод, чтобы определить доступность хоста и среднее время отклика (RTT).

**Функционал**:
- чтение списка хостов из файла (путь в `app.properties`)
- выполнение системной команды `ping` (количество пакетов задается в конфиге)
- **Задание 1 (Парсинг):** извлечь из вывода `ping` среднее время RTT (например, `average = 5.123 ms`). *Примечание: вывод `ping` отличается на Windows и Linux*
- **Задание 2 (Статус):** определить статус хоста: `UP` (если 0% потерь), `UNREACHABLE` (если 100% потерь или ошибка), `FLAKY` (если потери > 0% и < 100%)
- **Задание 3 (Сортировка):** Вывести отчет, отсортированный по статусу (сначала `UP`, потом `FLAKY`, потом `UNREACHABLE`), а внутри `UP` – по возрастанию RTT
    
**Формат входных данных:** Файл `hosts.txt` (путь из конфига).

```txt
8.8.8.8
google.com
192.168.100.255
github.com
```

**Формат выходных данных:** Текстовый отчет в `stdout`

```txt
HOST: 8.8.8.8, STATUS: UP, RTT: 5.12 ms
HOST: github.com, STATUS: UP, RTT: 22.45 ms
HOST: google.com, STATUS: FLAKY, RTT: 10.10 ms (50% loss)
HOST: 192.168.100.255, STATUS: UNREACHABLE
```

**Пример файла конфигурации:** (`app.properties`)

```Properties
# Файл со списком хостов
hosts.file.path=./config/hosts.txt
# Количество ping-пакетов для отправки
ping.count=4
# Таймаут ожидания ответа (в секундах)
ping.timeout.seconds=2
```

**Доп. задачи к CI/CD**:
- **Публикация артефакта:** собрать "толстый" `jar` и опубликовать его как артефакт сборки
- **Анализ покрытия кода**: использовать плагин JaCoCo, настроенный на "падение" сборки при покрытии классов бизнес-логики менее 70%
- **Сборка на разных JDK**: 11, 17, 21

#### 3. Сравнение файлов

**Описание:** Приложение, которое рекурсивно сканирует указанную директорию и генерирует snapshot файловой структуры в виде JSON-файла. Затем сравнивает два snapshot и показывает изменения.

**Функционал**:
- Два режима работы, задаваемые через аргументы командной строки: `scan` (сканирование) и `diff` (сравнение)
- Путь для сканирования и пути к файлам snapshot задаются через переменные окружения
- **Задание 1 (Scan):** при запуске в режиме `scan` рекурсивно обойти директорию (путь из `SCAN_PATH`), вычислить хэш (MD5/SHA1) для каждого файла и сохранить в JSON-файл (путь из `SNAPSHOT_OUTPUT`)
- **Задание 2 (Diff - Поиск):** в режиме `diff` (пути из `SNAPSHOT_OLD` и `SNAPSHOT_NEW`) найти файлы, которые были **Добавлены**, **Удалены** или **Изменены** (сравнивая хэши)
- **Задание 3 (Diff - Фильтрация):** В режиме `diff` игнорировать файлы с расширениями, перечисленными в `app.properties` (например, `*.log`, `*.tmp`)

**Формат входных данных:**
- Режим `scan`: Директория с файлами (путь из переменной среды `SCAN_PATH`)
- Режим `diff`: Два JSON-файла snapshot (пути из переменных среды `SNAPSHOT_OLD` и `SNAPSHOT_NEW`)

**Формат выходных данных:**
- Режим `scan`: JSON-файл snapshot
    ```JSON
    {
      "root_path": "/app/src",
      "files": [
        {"path": "main/App.java", "hash": "a1b2c3d4..."},
        {"path": "resources/config.ini", "hash": "e5f6g7h8..."}
      ]
    }
    ```
    
- Режим `diff`: Отчет в `stdout`
    ```txt
    CHANGED: /app/src/main/App.java
    ADDED: /app/src/docs/README.md
    REMOVED: /app/src/resources/config.ini
    ```

**Пример файла конфигурации:** (`app.properties`)

```Properties
# Алгоритм хэширования: MD5, SHA-1, SHA-256
hash.algorithm=MD5
# Паттерны для исключения при сканировании и сравнении (через запятую)
scan.ignore.patterns=*.log,*.tmp,*.bak
```

**Доп. задачи к CI/CD**:
- **Matrix на версии Java:** Собрать и протестировать приложение на нескольких версиях Java (JDK 11, 17, 21) используя `matrix`
- **Сборка на разных ОС:** настроить `matrix` для сборки на `ubuntu-latest`, `windows-latest`

#### 4. Анализатор дискового пространства

**Описание:** Приложение парсит вывод системных утилит `df` (Linux/macOS) или `wmic logicaldisk` (Windows) для создания отчета об использовании диска.

**Функционал**:
- Выполнение системной команды для получения информации о дисках (команда определяется в зависимости от ОС)
- **Задание 1 (Парсинг):** извлечь данные: Имя диска, Общий размер, Использовано, Свободно, % использования
- **Задание 2 (Фильтрация):** найти и вывести только те файловые системы, у которых процент использования **выше** порога, заданного в `app.properties`
- **Задание 3 (Агрегация):** подсчитать и вывести общий/использованный/свободный объем дискового пространства по всем дискам

**Формат входных данных:**  *Пример (Linux `df -h`)*:

```txt
Filesystem      Size  Used Avail Use% Mounted on
udev            3.9G     0  3.9G   0% /dev
/dev/sda1        97G   20G   73G  22% /
```

**Формат выходных данных:** JSON-отчет в `stdout`

```JSON
{
  "threshold_exceeded": [
    {"filesystem": "/dev/sdb1", "total": "500G", "used_percent": 95}
  ],
  "summary": {
    "total_gb": 597,
    "total_used_gb": 520
  }
}
```

**Пример файла конфигурации:** (`app.properties`)

```Properties
# Порог использования в %, при превышении которого диск попадает в отчет
usage.threshold.percent=90
# Единицы измерения для отчета: GB, MB, TB
output.units=GB
```

**Доп. задачи к CI/CD**:
- **Сборка на разных ОС:** настроить `matrix` для сборки на `ubuntu-latest` и `windows-latest`
- **Публикация артефакта:** собрать исполняемый `jar` и опубликовать его как артефакт
- **Статический анализ:** добавить шаг для запуска плагина `checkstyleMain` на проверку отсутствия deprecated методов. Сборка должна падать, если анализ не пройден

#### 5. Агрегатор CSV-данных о продажах

**Описание:** Приложение читает большой CSV-файл с данными о продажах, агрегирует и фильтрует их согласно настройкам.

**Функционал**:
- Чтение CSV-файла (путь из `app.properties`), где каждая строка - это транзакция.
- **Задание 1 (Агрегация):** подсчитать общую сумму продаж (колонка `Amount`), сгруппированную по `Region` (колонка `Region`)
- **Задание 2 (Сортировка/Поиск):** найти 10 самых дорогих продаж (`Amount`) и вывести их `TransactionID`
- **Задание 3 (Фильтрация):** отфильтровать и вывести все транзакции, где `ProductID` (из `app.properties`) совпадает с заданным

**Формат входных данных:** `sales.csv`

```
TransactionID,Date,ProductID,Amount,Region
1001,2025-10-10,P-123,150.00,North
1002,2025-10-10,P-456,20.50,South
1003,2025-10-11,P-123,150.00,West
```

**Формат выходных данных:** Текстовый отчет в `stdout` или в файл (зависит от конфига)

```txt
--- Sales by Region ---
North: 150.00
South: 20.50
West: 150.00

--- Top 10 Sales (ID) ---
1001
1003

--- Filtered by Product P-456 ---
1002,2025-10-10,P-456,20.50,South
```

**Пример файла конфигурации:** (`app.properties`)

```Properties
# Путь к входному CSV
csv.input.path=./data/sales.csv
# ID продукта для фильтрации
filter.product.id=P-456
# Количество записей для топа
report.top.sales.count=10
# Разделитель в CSV ( , или ; )
csv.separator=,
# Вывод в stdout
report.output=STDOUT
```

**Доп. задачи к CI/CD**:
- **Кэширование зависимостей:** Настроить `actions/cache` для `.gradle/caches`
- **Тестирование на разных JDK:** Использовать `matrix` для сборки и тестов на Java 11, 17, 21
- **Анализ покрытия кода**: использовать плагин JaCoCo, настроенный на "падение" сборки при покрытии пакетов бизнес-логики менее 80%

#### 6. Анализатор логов Git

**Описание:** Приложение запускает `git log` в текущем репозитории и анализирует вывод, чтобы построить статистику по коммитам.

**Функционал**:
- Выполнение команды `git log`
- **Задание 1 (Агрегация):** подсчитать общее количество коммитов на каждого автора и вывести топ-3
- **Задание 2 (Поиск):** найти все коммиты (хэш и сообщение), содержащие ключевые слова (например, "FIX:", "BUG:", "HOTFIX:"), список слов берется из `app.properties`.
- **Задание 3 (Сортировка):** вывести список всех авторов (уникальных) в алфавитном порядке.

**Формат входных данных:**

```txt
a1b2c3d|Alice|FIX: Critical bug in login
e4f5g6h|Bob|Initial commit
i7j8k9l|Alice|Update README
```

**Формат выходных данных:** JSON-отчет в `stdout`

```JSON
{
  "top_authors": [
    {"name": "Alice", "commits": 2},
    {"name": "Bob", "commits": 1}
  ],
  "found_keywords": [
    {"hash": "a1b2c3d", "message": "FIX: Critical bug in login"}
  ],
  "all_authors": ["Alice", "Bob"]
}
```

**Пример файла конфигурации:** (`app.properties`)

```Properties
# Ключевые слова для поиска (через запятую)
git.search.keywords=FIX:,BUG:,HOTFIX:
# Формат вывода: JSON или PLAINTEXT
output.format=JSON
```

**Доп. задачи к CI/CD**:
- **Публикация JAR:** собрать `jar` и опубликовать как артефакт
- **Сборка на разных ОС:** настроить `matrix` для сборки на `ubuntu-latest`, `windows-latest` и `macos-latest`

#### 7. Поиск "TODO" в исходном коде

**Описание:** Приложение рекурсивно сканирует указанную директорию, ищет в файлах (с определенными расширениями) комментарии "TODO", "FIXME" и генерирует отчет.

**Функционал**:
- Рекурсивный обход директории (путь из `app.properties`)
- **Задание 1 (Поиск):** найти все строки-комментарии в коде, содержащие "TODO", "FIXME"
- **Задание 2 (Группировка):** сгруппировать найденные строки по файлам
- **Задание 3 (Фильтрация):** искать только в файлах с расширениями, указанными в конфиге (например, `.java`, `.kt`, `.md`)

**Формат входных данных:**

```Java
public class MyClass {
    // TODO: Need to refactor this
    public void doWork() { ... }
    // FIXME: This is slow
    public void doMoreWork() { ... }
}
```

**Формат выходных данных:**

```txt
Found 3 issues:

[src/main/java/MyClass.java]
  L3: TODO: Need to refactor this
  L5: FIXME: This is slow

[README.md]
  L10: TODO: Remember to update screenshots
```

**Пример файла конфигурации:** (`app.properties`)

```Properties
# Директория для сканирования
scan.source.directory=./src
# Расширения файлов для сканирования (через запятую)
scan.file.extensions=.java,.kt,.xml,.md
# Ключевые слова для поиска (через запятую, регистронезависимо)
scan.keywords=TODO,FIXME
```

**Доп. задачи к CI/CD**:
- **Сборка на разных JDK**: 11, 17, 21
- **Создание релиза на GitHub.** Настройте workflow так, чтобы при создании нового тега (например, `v1.0.0`) он автоматически создавал релиз на GitHub и прикреплял к нему собранный `.jar` файл из артефактов

#### 8. Монитор сетевых соединений (netstat)

**Описание:** Java-приложение, которое выполняет `netstat -ano` (Windows) или `netstat -anp` (Linux), парсит вывод и ищет заданные соединения.

**Функционал**:
- Выполнение `netstat` и парсинг `stdout`
- **Задание 1 (Поиск):** найти и вывести все PID/Процессы, которые держат порт в состоянии `LISTEN`
- **Задание 2 (Поиск):** найти все внешние (`ESTABLISHED`) и вывести их `Foreign Address`
- **Задание 3 (Поиск):** проверить, занят ли порт, указанный в `app.properties`. Если да, вывести PID процесса, который его занял
    
**Формат входных данных:** *Пример (Linux)*:

```txt
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 127.0.0.1:3306          0.0.0.0:* LISTEN      1234/mysqld
tcp        0      0 192.168.1.10:1234       104.18.3.10:443         ESTABLISHED 5678/java
```

**Формат выходных данных:** Отчет в `stdout`

```txt
--- Listening Ports ---
PID: 1234, Process: mysqld, Port: 3306

--- External Connections ---
PID: 5678, Process: java, Foreign: 104.18.3.10:443

--- Port 8080 Check ---
Port 8080 is not in use.
```

**Пример файла конфигурации:** (`app.properties`)

```Properties
# Порт, который нужно проверить на занятость
monitor.port.check=8080
# Режим вывода: VERBOSE (все) или SUMMARY (только проблемы)
output.mode=VERBOSE
```

**Доп. задачи к CI/CD**:
- **Matrix по ОС:** `ubuntu-latest` и `windows-latest`. Формат вывода `netstat` **абсолютно разный**, и парсер должен это учитывать
- **Сборка JAR-файла:** Добавьте шаг `./gradlew build` и опубликуйте итоговый `.jar` файл как артефакт сборки

#### 9. Преобразователь вложенного JSON в "плоский" (Flat-JSON)

**Описание:** Приложение читает сложный, вложенный JSON-файл и преобразует его в "плоскую" структуру (ключи с точками) и ищет в нем данные.

**Функционал**:
- Чтение JSON из файла (путь из переменной среды `INPUT_JSON`)
- **Задание 1 (Преобразование):** "Развернуть" JSON: `{ "user": { "name": "Test" } }` превращается в `{ "user.name": "Test" }`
- **Задание 2 (Поиск):** Найти значение по "плоскому" ключу (ключ задан в `app.properties`, например `search.key=user.address.city`)
- **Задание 3 (Фильтрация):** Обработать массив JSON-объектов, оставив только те, у которых `user.status == "ACTIVE"`.
    
**Формат входных данных:** `input.json`

```JSON
{
  "request_id": "tx-123",
  "payload": {
    "user": {
      "name": "Alice",
      "address": {
        "city": "New York",
        "zip": "10001"
      },
      "status": "ACTIVE"
    }
  }
}
```

**Формат выходных данных:** `stdout`

```JSON
{
  "request_id": "tx-123",
  "payload.user.name": "Alice",
  "payload.user.address.city": "New York",
  "payload.user.address.zip": "10001",
  "payload.user.status": "ACTIVE"
}
```

**Пример файла конфигурации:** (`app.properties`)

```Properties
# Ключ для поиска
search.key=payload.user.address.city
# Ключ для фильтрации
filter.key=payload.user.status
filter.value=ACTIVE
```

**Доп. задачи к CI/CD**:
- **Кэширование:** настроить `actions/cache` для кэширования зависимостей Gradle (папки `.gradle/caches` и `.gradle/wrapper`) для ускорения последующих сборок
- **Анализ покрытия кода**: использовать плагин JaCoCo, настроенный на "падение" сборки при покрытии методов бизнес-логики менее 75%
- **Статический анализ:** добавить шаг для запуска плагина `checkstyleMain` на проверку максимальной длины строки кода (задать самостоятельно). Сборка должна падать, если анализ не пройден

#### 10. Генератор Mock-данных

**Описание:** Приложение генерирует N строк тестовых данных (CSV или JSON) на основе шаблона, заданного в `app.properties`

**Функционал**:
- Чтение конфигурации для генерации
- **Задание 1 (Генерация):** генерировать N записей
- **Задание 2 (Форматирование):** поддержка генерации в `CSV` и `JSON` (формат из конфига)
- **Задание 3 (Типы данных):** поддержка шаблонов полей: `uuid` (случайный UUID), `name` (случайное имя), `email` (случайный email), `int(min,max)` (случайное число в диапазоне)

**Формат выходных данных:**  *Пример вывода (для `output.format=CSV`)*:

```CSV
id,user_name,user_email
1,John Doe,john.doe@example.com
2,Jane Smith,jane.smith@example.com
... (еще 9998 строк)
```

**Пример файла конфигурации:** (`app.properties`)

```Properties
# Количество строк для генерации
generator.rows.count=10000
# Формат вывода: CSV или JSON
output.format=CSV
# Описание полей. Формат: <имя_колонки>:<тип_генератора>
generator.fields=id:int(1,100000),user_name:name,user_email:email
```

**Доп. задачи к CI/CD**:
- **Публикация JAR:** Собрать `jar` и опубликовать как артефакт
- **Тестирование на разных JDK** (11, 17, 21)
- **Кэширование:** настроить `actions/cache` для кэширования зависимостей Gradle (папки `.gradle/caches` и `.gradle/wrapper`) для ускорения последующих сборок

#### 11. Сбор информации о системе

**Описание:** Приложение собирает базовую информацию о системе (CPU, RAM, OS), используя системные утилиты, и выводит ее в едином JSON-формате.

**Функционал**:
- Определение ОС и выбор правильной команды (`lscpu`/`cat /proc/meminfo` для Linux, `systeminfo` для Windows)
- **Задание 1 (Парсинг CPU):** извлечь модель CPU и количество ядер
- **Задание 2 (Парсинг RAM):** извлечь общий объем оперативной памяти
- **Задание 3 (Парсинг OS):** Извлечь название и версию ОС

**Формат выходных данных:** `stdout`

```JSON
{
  "os": {
    "name": "Ubuntu",
    "version": "22.04"
  },
  "cpu": {
    "model": "Intel(R) Core(TM) i7-10750H",
    "cores": 12
  },
  "memory": {
    "total_mb": 15998
  }
}
```

**Пример файла конфигурации:** (`app.properties`)

```Properties
# Формат вывода памяти: MB или GB
memory.output.unit=MB
# Включить ли в отчет информацию об IP (требует доп. команды)
include.network.info=false
```

**Доп. задачи к CI/CD**:
- **Matrix по ОС:** `ubuntu-latest` и `windows-latest`. Парсеры должны работать для обеих ОС
- **Публикация JAR:** собрать `jar` и опубликовать как артефакт
- **Статический анализ:** добавить шаг для запуска плагина `checkstyleMain` на проверку отсутствия deprecated методов. Сборка должна падать, если анализ не пройден

#### 12. Анализатор процессов (ps/tasklist)

**Описание:** Приложение парсит вывод `ps aux` (Linux) или `tasklist` (Windows) и ищет процессы, потребляющие много ресурсов.

**Фуционал**:
- Выполнение `ps` или `tasklist` и парсинг `stdout`
- **Задание 1 (Сортировка):** отсортировать все процессы по % CPU (убывание) или RAM (убывание) – режим из `app.properties`.
- **Задание 2 (Поиск):** найти PID процесса по его имени (имя из `app.properties`, например, "java")
- **Задание 3 (Фильтрация):** найти и вывести все процессы, потребляющие > N% CPU **или** > M MB RAM (пороги N и M из `app.properties`)

**Формат входных данных:** *Пример (Windows `tasklist`)*:

```
Image Name                     PID Session Name        Session#    Mem Usage
========================= ======== ================= =========== ============
System                           4 Services                   0      1,234 K
java.exe                    123456 Console                    1    512,345 K
```

**Формат выходных данных:** Текстовый отчет в `stdout`

```
--- Top 5 by CPU ---
PID: 1234, CPU: 15.2%, MEM: 500M, Name: java
...

--- Processes above threshold (CPU > 10% or MEM > 1000M) ---
...
```

**Пример файла конфигурации:** (`app.properties`)

```Properties
# Режим сортировки: CPU или MEMORY
sort.by=CPU
# Пороги для фильтрации
threshold.cpu.percent=10
threshold.memory.mb=1000
# Имя процесса для поиска PID
search.process.name=java
```

**Доп. задачи к CI/CD**:
- **Matrix по ОС:** `ubuntu-latest` и `windows-latest`. Разные команды и форматы вывода
- **Создание релиза на GitHub.** Настройте workflow так, чтобы при создании нового тега (например, `v1.0.0`) он автоматически создавал релиз на GitHub и прикреплял к нему собранный `.jar` файл из артефактов
- **Статический анализ:** добавить шаг для запуска плагина `checkstyleMain` на проверку отсутствия deprecated методов. Сборка должна падать, если анализ не пройден

#### 13. Фильтр и форматер логов

**Описание:** Приложение читает структурированный лог (например, стандартный лог Spring Boot) из `stdin` и фильтрует/переформатирует его в `stdout`.

**Функционал**:
- Чтение `stdin` построчно (для работы в "пайплайне": `cat app.log | java -jar ...`)
- **Задание 1 (фильтрация по уровню):** выводить только строки, содержащие `ERROR` (или `WARN`, `INFO` - уровень из `app.properties`)
- **Задание 2 (поиск по контексту):** выводить только строки, содержащие ID (например, `[TraceID: xyz-123]`) или текст из `app.properties`
- **Задание 3 (Преобразование):** переформатировать вывод. Например, из `2025-10-10 10:00:00 INFO [main] ...` сделать `[INFO] ...`

**Формат входных данных:**

```
2025-10-10 10:00:00.100 INFO [main] com.app.Main: Starting app...
2025-10-10 10:00:01.200 WARN [task-1] com.app.Task: Task running slow...
2025-10-10 10:00:02.300 ERROR [main] com.app.Main: Failed to start!
```

**Формат выходных данных:** `stdout` (отфильтрованный/измененный лог). *При `filter.level=ERROR`*:

```
[ERROR] Failed to start!
```

**Пример файла конфигурации:** (`app.properties`)

```Properties
# Уровень логгирования для фильтрации: INFO, WARN, ERROR (пусто = все)
filter.level=ERROR
# Текст для поиска (пусто = не используется)
filter.contains.text=
# Формат вывода: SIMPLE (только сообщение), COMPACT ([LEVEL] сообщение), FULL (как было)
output.format=COMPACT
```

**Доп. задачи к CI/CD**:
- **Тестирование на разных JDK** (11, 17, 21)
- **Кэширование:** настроить `actions/cache` для кэширования зависимостей Gradle (папки `.gradle/caches` и `.gradle/wrapper`) для ускорения последующих сборок
- **Анализ покрытия кода**: использовать плагин JaCoCo, настроенный на "падение" сборки при покрытии пакетов бизнес-логики менее 80%

#### 14. Поиск дубликатов файлов

**Описание:** Приложение рекурсивно сканирует директорию и находит файлы-дубликаты путем сравнения хэш-сумм.

**Функционал**:
- Рекурсивный обход директории (путь из `app.properties`)
- **Задание 1 (Группировка по размеру):** перед хэшированием сгруппировать файлы по размеру
- **Задание 2 (Хэширование):** для файлов с одинаковым размером рассчитать хэш (MD5 или SHA-256, алгоритм из конфига) и сравнить
- **Задание 3 (Отчет):** вывести группы файлов-дубликатов

**Формат выходных данных:** `stdout`

```
--- Found Duplicates ---

Group 1 (Hash: a1b2c3d4...):
 - /data/docs/file.txt
 - /data/backup/file.txt.bak

Group 2 (Hash: e5f6g7h8...):
 - /data/images/img1.jpg
 - /data/archive/photo.jpg
```

**Пример файла конфигурации:** (`app.properties`)

```Properties
# Директория для сканирования
scan.directory=./data
# Алгоритм хэширования: MD5, SHA-256
hash.algorithm=MD5
# Исключить директории (через запятую)
scan.ignore.dirs=target,.git,build
```

**Доп. задачи к CI/CD**:
- **Matrix по ОС:** проверить работу на `ubuntu-latest` и `windows-latest`
- **Публикация JAR:** собрать `jar` и опубликовать как артефакт

#### 15. Валидатор URL-адресов

**Описание:** Приложение читает файл со списком URL-адресов, "пингует" каждый (отправляет HTTP HEAD/GET запрос) и сообщает о "мертвых" ссылках.

**Функционал**:
- Чтение файла со списком URL (путь из `app.properties`)
- **Задание 1 (Проверка):** для каждого URL выполнить HTTP HEAD (или GET) запрос, используя `java.net.http.HttpClient`
- **Задание 2 (Классификация):** классифицировать результат: `OK` (код 2xx), `REDIRECTION` (код 3xx), `CLIENT_ERROR` (код 4xx), `SERVER_ERROR` (код 5xx), `TIMEOUT` (если таймаут из конфига превышен)
- **Задание 3 (Сортировка):** вывести отчет, сгруппированный по статусам
    
**Формат входных данных:** `urls.txt`

```
https://google.com
https://github.com
https://google.com/no-such-page-404
https://httpstat.us/503
```

**Формат выходных данных:** `stdout`

```
--- FAILED URLS ---
[CLIENT_ERROR: 404] https://google.com/no-such-page-404
[SERVER_ERROR: 503] https://httpstat.us/503

--- OK URLS ---
[OK: 200] https://google.com
[OK: 200] https://github.com
```

**Пример файла конфигурации:** (`app.properties`)

```Properties
# Путь к файлу с URL
urls.file.path=./config/urls.txt
# Таймаут HTTP запроса (в миллисекундах)
http.timeout.ms=5000
# Метод запроса: HEAD или GET
http.method=HEAD
```

**Доп. задачи к CI/CD**:
- **Статический анализ:** добавить шаг для запуска плагина `checkstyleMain` на проверку покрытия всех методов автодокументацией JavaDoc. Сборка должна падать, если анализ не пройден
- **Сборка на разных JDK**: 11, 17, 21

#### 16. Простой шаблонизатор

**Описание:** Приложение читает "шаблон" (`template.txt`) и "данные" (`data.properties` или `data.json`) и генерирует итоговый файл, заменяя плейсхолдеры.

**Функционал**:
- Чтение файла шаблона (путь из конфига)
- Чтение файла данных (путь из конфига)
- **Задание 1 (Замена):** найти в шаблоне все плейсхолдеры (например, `${user.name}`) и заменить их значениями из файла
- **Задание 2 (Поддержка .properties):** реализовать парсер для `data.properties`
- **Задание 3 (Поддержка JSON):** Реализовать парсер для `data.json` (используя "плоские" ключи, см. Вариант 9)

**Формат входных данных:** `template.txt`:

```
Hello, ${user.name}!
Your order ${order.id} is confirmed.
Total: $${order.total}
```

`data.properties`:

```Properties
user.name=Bob
order.id=A-123
order.total=99.50
```

**Формат выходных данных:** `stdout`

```
Hello, Bob!
Your order A-123 is confirmed.
Total: $99.50
```

**Пример файла конфигурации:** (`app.properties`)

```Properties
# Путь к файлу шаблона
template.file.path=./templates/email.txt
# Путь к файлу данных
data.file.path=./data/order1.properties
# Формат данных: PROPERTIES или JSON
data.format=PROPERTIES
```

**Доп. задачи к CI/CD**:
- **Создание релиза на GitHub.** Настройте workflow так, чтобы при создании нового тега (например, `v1.0.0`) он автоматически создавал релиз на GitHub и прикреплял к нему собранный `.jar` файл из артефактов.
- **Анализ покрытия кода**: использовать плагин JaCoCo, настроенный на "падение" сборки при покрытии классов бизнес-логики менее 90%
- **Кэширование:** настроить `actions/cache` для кэширования зависимостей Gradle (папки `.gradle/caches` и `.gradle/wrapper`) для ускорения последующих сборок

#### 17. Поиск текста в файлах

**Описание:** Приложение рекурсивно сканирует указанную в конфигурации директорию, ищет во всех файлах с расширением `.txt` (или другими, указанными в конфиге) заданное ключевое слово и выводит в `stdout` список файлов, в которых это слово было найдено.

**Функционал**:
- Чтение `app.properties` для получения пути к директории, ключевого слова и других настроек
- **Задание 1 (Поиск):** рекурсивно обойти указанную директорию. В каждом файле, расширение которого совпадает со списком `scan.file.extensions`, выполнить поиск `search.keyword`
- **Задание 2 (Фильтрация):** реализовать настройку `search.case.sensitive` (true/false) для регистрозависимого или регистронезависимого поиска
- **Задание 3 (Вывод):** вывести в `stdout` полные (абсолютные) пути к файлам, где найдено хотя бы одно совпадение. Каждый файл должен быть выведен только один раз, независимо от количества совпадений в нем

**Формат выходных данных:** `stdout`

```
/home/user/project/data/logs/errors.txt
```

**Пример файла конфигурации:** (`app.properties`)

```Properties
# Директория для сканирования
scan.directory=./data
# Ключевое слово для поиска
search.keyword=CRITICAL
# Учитывать ли регистр (true/false)
search.case.sensitive=false
# Расширения файлов для сканирования (через запятую)
scan.file.extensions=.txt,.log
```

**Доп. задачи к CI/CD**:
- **Matrix по ОС:** на `ubuntu-latest` и `windows-latest`
- **Публикация JAR:** cобрать исполняемый `jar` и опубликовать его как артефакт сборки
- **Статический анализ:** добавить шаг для запуска плагина `checkstyleMain` на проверку покрытия всех методов и классов автодокументацией JavaDoc. Сборка должна падать, если анализ не пройден

### Отчет по лабораторной работе должен содержать

1. Цель и задачи работы.
2. Структура проекта, используемые зависимости и плагины.
3. Список тестов и их описание.
4. Скриншоты с результатами прохожождения тестов и работы приложения.
5. Описание workflow-файла.
6. Результат сборки проекта в Github Actions.
7. Вывод по выполненной работе.

### Список вопросов на защиту

1. Что такое CI/CD и какова его основная цель в современном процессе разработки программного обеспечения.
2. Объясните разницу между непрерывной интеграцией (CI) и непрерывной доставкой/развертыванием (CD).
3. Какие этапы обычно включает pipeline CI\CD (т.е. этапы сборки и запуска приложения)?
4. Что такое GitHub Actions и какую роль он играет в автоматизации процессов CI/CD.
5. Что такое workflow в GitHub Actions?
6. Назовите и опишите основные структурные элементы workflow-файла.
7. Что такое событие (event) в GitHub Actions и как оно определяет, когда должен запускаться workflow.
8. Что такое job (задание) и как определяется среда выполнения для задания.
9. Что такое step (шаг) в рамках job? Опишите разницу между использованием uses и run.
10. Какие преимущества использования Gradle по сравнению с Maven (в контексте сборки)?
11. Что такое секреты (Secrets) в GitHub Actions? Объясните, почему их необходимо использовать, например, при развертывании приложения.
12. Что такое артефакты сборки в контексте CI/CD? Какие действия (actions) используются в GitHub Actions для загрузки и скачивания артефактов.
13. Опишите, как можно интегрировать в процесс сборки инструменты статического анализа кода (например, Checkstyle) и как настроить workflow так, чтобы неуспешный результат анализа приводил к провалу сборки.
14. Как в workflow-файл можно добавить этап для запуска юнит-тестов?
15. Как в GitHub Actions можно использовать кэширование (например, для зависимостей Gradle) и зачем это нужно.