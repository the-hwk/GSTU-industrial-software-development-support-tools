**Инструменты поддержки промышленной разработки программного обеспечения**
## Лабораторная работа №3 (8 ч)

**Тема:** Автоматизация сборки, тестирования и развёртывания программного обеспечения в системе CI/CD.

**Цель работы:** Освоить базовые принципы CI/CD и их роль в промышленной разработке ПО. Получить практические навыки настройки автоматизированной сборки, тестирования и развертывания Java-проекта в системе CI/CD.

### Теоретические сведения

#### Что такое CI/CD

Непрерывная интеграция (Continuous Integration, CI) и непрерывная доставка (Continuous Delivery, CD) представляют собой набор принципов и практик, которые позволяют разработчикам чаще и надежнее развертывать изменения программного обеспечения.

Непрерывная интеграция (CI) - это автоматическая интеграция кода в репозиторий проекта. Цель CI - упростдить объединение кода от разных разработчиков и быстро выявлять ошибки. Когда программист отправляет код в репозиторий, система запускает тесты.

Непрерывная доставка и развертывание (CD) обеспечивают автоматическую подготовку и доставку приложения в рабочее или тестовое окружение. 

CI/CD помогает быстрее выпускать новые версии программы, не тратя время на ручную сборку и развертывание, а значит - меньше ошибок и больше скорости в разработке.

CI/CD можно объяснить очень просто. Представьте, что у вас есть проект, над которым работает команда. Каждый пишет свой кусочек кода, и нужно, чтобы все это вместе работало без ошибок. CI - это когда кто-то добавляет изменения в репозиторий и автоматически запускается проверка: собирается проект, выполняются тесты, и сразу видно, не сломалось ли что-то. CD - это следующий шаг: после успешной проверки приложение автоматически упаковывается и отправляется на рабочий или тестовый сервер/облако, с которого приложение доступно пользователям.

#### GitHub Actions

GitHub Actions - это встроенная в GitHub платформа автоматизации, которая позволяет запускать рабочие процессы при наступлении событий в репозитории. По сути, это оркестратор задач, который реагирует на изменения кода и выполняет набор шагов: сборку, тестирование, упаковку артефактов и развертывание.

##### Кратко о возможностях и типовых сценариях

GitHub Actions предоставляет хостируемые виртуальные машины с предустановленными инструментами, кэширование зависимостей, секреты и переменные окружения, хранение артефактов и тонкую оркестрацию шагов. 

В контексте Java-проекта с Gradle это означает возможность автоматически запускать wrapper-скрипт, прогонять юнит-тесты, собирать jar/war, а затем деплоить на целевую платформу.

Сердцем этой автоматизации является workflow-файл.

##### Что такое Workflow-файл

Workflow описывается в YAML-файле (`.yml` или `.yaml`) внутри каталога `.github/workflows`. В этом файле вы описываете, что нужно сделать и когда это нужно сделать. Например: когда кто-то делает `push` в ветку `main`, что нужно сделать: взять код, установить Java, запустить команду `./gradlew build`.

Ниже представлен пример workflow-файла:

```YAML
# .github/workflows/build.yml

# 1. Название Workflow
name: Java CI with Gradle

# 2. Триггер: запускать при push в ветку main
on:
  push:
    branches: [ "main" ]

# 3. Работы (задания)
jobs:
  # 4. Название работы (job_id) - "build"
  build:

    # 5. На какой ОС запускать
    runs-on: ubuntu-latest

    # 6. Шаги, которые нужно выполнить
    steps:
      # 7. Шаг 1: "uses" - скачать код репозитория
      - name: Checkout repository
        uses: actions/checkout@v4

      # 8. Шаг 2: "uses" - установить Java (JDK 17)
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin' # Популярный дистрибутив Java

      # 9. Шаг 3: "run" - даем права на выполнение Gradle-скрипту
      - name: Grant execute permission for gradlew
        run: chmod +x gradlew

      # 10. Шаг 4: "run" - запускаем сборку и тесты
      - name: Build with Gradle
        run: ./gradlew build
```

Разберем подробнее ключевые блоки:
- `name` - название вашего workflow. Оно будет отображаться во вкладке Actions в GitHub
- `on` - событие, при наступлении которого запускается workflow
- `jobs` - контейнер для всех работ (заданий), которые нужно выполнить
	- `<job_id>` - название работы (например, `build`)
	- `runs-on` - виртуальная машина (ОС), на котором будут выполняться задачи. GitHub предоставляет их бесплатно
	- `steps` - последовательность шагов (команд), которые нужно выполнить
		- каждый шаг начинается с символа `-`
		- `uses` - использует готовое действие (Action), созданное сообществом или GitHub. Это похоже импорт библиотеки
		- `run` - выполняет команду в командной строке (shell) виртуальной машины

##### Создание Workflow-файла

1. Зайдите в репозиторий на GitHub.
2. Нажмите на вкладку **Actions** (она находится рядом с **Code**, **Issues**, **Pull Requests**).
3. GitHub проанализирует код и, увидев Java/Gradle, сам предложит шаблон.
4. Найдите карточку **Java with Gradle** и нажмите **Configure**.
5. GitHub откроет редактор и создаст файл `.yml` с уже готовым кодом. *Примечание:* GitHub-шаблон может быть сложнее, чем нужно. Вы можете полностью удалить его содержимое и вставить пример, который приведен выше, чтобы лучше понять основы.
6. Когда закончите редактирование, нажмите на кнопку **Commit changes**.
7. Готово! Workflow-файл сохранен в `.github/workflows/`. Перейдите снова на вкладку **Actions** - Вы увидите, как ваш первый workflow уже запущен.

##### Дополнительные возможности

Workflow-файл - это только начало. В **Actions** можно найти другие инструменты:
- **просмотр логов**: Вы можете кликнуть на любой запущенный workflow и посмотреть детальные логи каждого шага. Если сборка или тесты "упали" (failed), Вы увидите красный крестик и сможете прочитать ошибку прямо в логах
- **секреты (Secrets):** если Вам нужно использовать секретные данные (пароль от базы данных, API-ключ), их нельзя писать в YAML-файл. Вы можете сохранить их в **Settings -> Secrets and variables -> Actions**. Они будут безопасно переданы в workflow
- **Артефакты (Artifacts):** после шага `./gradlew build` появляется `.jar` файл. Но виртуальная машина удаляется после выполнения. Чтобы сохранить этот `.jar`, Вы можете добавить шаг `actions/upload-artifact` в workflow-файл. Это позволит скачать собранное приложение прямо со страницы workflow
- **Матрица сборок (Matrix builds):** используется для сборки одного и того же кода с разными параметрами, например, на разных JDK (например, Java 8, 11 и 17) или на разных ОС (например, Ubuntu и Windows)

### Задание

Разработать Java-приложение согласно варианта (по списку в журнале) со сборщиком Gradle. Настроить GitHub Actions workflow для автоматической сборки проекта, запуска тестов и других действий согласно варианта.

**Требования к ПО:**
- код должен быть логически разделен на классы и пакеты
- весь код бизнес-логики должен быть задокументирован с использованием JavaDoc
- весь код бизнес-логики должен быть покрыт тестами

**Общие требования:**
- использовать Git согласно методике, описанной в л.р. №1 (т.е. использовать ветки, поддерживать версионность, описывать изменения)
	- если нет должной истории проекта или временной промежуток между начальной и конечной версии проекта слишком короткий, то л.р. считается невыполненной
	- к проекту должна быть документация по развертыванию и запуску
	- в истории коммитов в поле "автор" должны быть указаны Ваши фамилия и имя

### Варианты

#### 1. Анализатор логов Nginx

**Описание:** Приложение парсит файлы `access.log` (в стандартном формате Nginx) для извлечения статистики.

**Функционал**:
- Чтение лог-файла, путь к которому указан в `app.properties`
- **Задание 1 (Поиск):** найти 10 IP-адресов, с которых было совершено больше всего запросов
- **Задание 2 (Агрегация):** подсчитать общее количество запросов по кодам ответа (200, 404, 501 и т.д.) и вывести статистику
- **Задание 3 (Фильтрация):** найти все запросы, пришедшие от определенного User-Agent (задается в `app.properties`)

**Формат входных данных:** стандартный Nginx `access.log` (генерируемый или реальный)

```txt
192.168.1.1 - - [10/Nov/2025:10:00:00 +0100] "GET /index.html HTTP/1.1" 200 1234 "-" "Mozilla/5.0..."
192.168.1.2 - - [10/Nov/2025:10:00:01 +0100] "GET /api/user HTTP/1.1" 404 150 "-" "curl/7.68.0"
...
```

**Формат выходных данных:** JSON-отчет в `stdout` или в файл (зависит от конфигурации)

```JSON
{
  "top_ips": [
    {"ip": "192.168.1.1", "count": 50},
    {"ip": "192.168.1.2", "count": 30}
  ],
  "status_codes": {
    "200": 50,
    "404": 30
  },
  "user_agent_hits": 15
}
```

**Пример файла конфигурации:** (`app.properties`)

```Properties
# Путь к лог-файлу
log.file.path=./data/access.log
# Количество IP-адресов для топа
report.top.ip.count=10
# User-Agent для поиска
filter.user.agent=curl/7.68.0
# Тип вывода: STDOUT или FILE
output.target=STDOUT
```

**Доп. задачи к CI/CD**:
- **Сборка на разных ОС:** настроить `matrix` для сборки на `ubuntu-latest`, `windows-latest` и `macos-latest`
- **Статический анализ:** добавить шаг для запуска `gradlew checkstyleMain` (требует плагина Checkstyle). Сборка должна падать, если анализ не пройден
- **Кэширование:** настроить `actions/cache` для кэширования зависимостей Gradle (папки `.gradle/caches` и `.gradle/wrapper`) для ускорения последующих сборок

#### 2. Утилита "Пинг-монитор"

**Описание:** Java-приложение, которое читает список хостов (IP-адресов или доменных имен) из файла, выполняет для каждого системную команду `ping` и парсит ее вывод, чтобы определить доступность хоста и среднее время отклика (RTT).

**Функционал**:
- чтение списка хостов из файла (путь в `app.properties`)
- выполнение системной команды `ping` (количество пакетов задается в конфиге)
- **Задание 1 (Парсинг):** извлечь из вывода `ping` среднее время RTT (например, `average = 5.123 ms`). *Примечание: вывод `ping` отличается на Windows и Linux*
- **Задание 2 (Статус):** определить статус хоста: `UP` (если 0% потерь), `UNREACHABLE` (если 100% потерь или ошибка), `FLAKY` (если потери > 0% и < 100%)
- **Задание 3 (Сортировка):** Вывести отчет, отсортированный по статусу (сначала `UP`, потом `FLAKY`, потом `UNREACHABLE`), а внутри `UP` – по возрастанию RTT
    
**Формат входных данных:** Файл `hosts.txt` (путь из конфига).

```txt
8.8.8.8
google.com
192.168.100.255
github.com
```

**Формат выходных данных:** Текстовый отчет в `stdout`

```txt
HOST: 8.8.8.8, STATUS: UP, RTT: 5.12 ms
HOST: github.com, STATUS: UP, RTT: 22.45 ms
HOST: google.com, STATUS: FLAKY, RTT: 10.10 ms (50% loss)
HOST: 192.168.100.255, STATUS: UNREACHABLE
```

**Пример файла конфигурации:** (`app.properties`)

```Properties
# Файл со списком хостов
hosts.file.path=./config/hosts.txt
# Количество ping-пакетов для отправки
ping.count=4
# Таймаут ожидания ответа (в секундах)
ping.timeout.seconds=2
```

**Доп. задачи к CI/CD**:
- **Тестирование на разных ОС (Matrix):** тесты (unit-тесты, симулирующие вывод `ping`) должны запускаться на `ubuntu-latest` и `windows-latest`. Workflow должен проверять, что парсер корректно работает с _разными форматами вывода_ `ping` на этих ОС
- **Публикация артефакта:** Собрать "толстый" `jar` и опубликовать его как артефакт сборки (upload-artifact)

#### 3. Сравнение файлов

**Описание:** Приложение, которое сканирует указанную директорию (рекурсивно или нет) и генерирует snapshot файловой структуры в виде JSON-файла. Затем сравнивает два snapshot и показывает изменения.

**Функционал**:
- Два режима работы, задаваемые через аргументы командной строки: `scan` (сканирование) и `diff` (сравнение)
- Путь для сканирования и пути к файлам snapshot задаются через переменные окружения (ENV)
- **Задание 1 (Scan):** при запуске в режиме `scan` рекурсивно обойти директорию (путь из `SCAN_PATH`), вычислить хэш (MD5/SHA1) для каждого файла и сохранить в JSON-файл (путь из `SNAPSHOT_OUTPUT`)
- **Задание 2 (Diff - Поиск):** в режиме `diff` (пути из `SNAPSHOT_OLD` и `SNAPSHOT_NEW`) найти файлы, которые были **Добавлены**, **Удалены** или **Изменены** (сравнивая хэши)
- **Задание 3 (Diff - Фильтрация):** В режиме `diff` игнорировать файлы с расширениями, перечисленными в `app.properties` (например, `*.log`, `*.tmp`)

**Формат входных данных:**
- Режим `scan`: Директория с файлами (путь из переменной среды `SCAN_PATH`)
- Режим `diff`: Два JSON-файла snapshot (пути из переменных среды `SNAPSHOT_OLD` и `SNAPSHOT_NEW`)

**Формат выходных данных:**
- Режим `scan`: JSON-файл snapshot
    
    ```JSON
    {
      "root_path": "/app/src",
      "files": [
        {"path": "main/App.java", "hash": "a1b2c3d4..."},
        {"path": "resources/config.ini", "hash": "e5f6g7h8..."}
      ]
    }
    ```
    
- Режим `diff`: Отчет в `stdout`
    ```txt
    CHANGED: /app/src/main/App.java
    ADDED: /app/src/docs/README.md
    REMOVED: /app/src/resources/config.ini
    ```

**Пример файла конфигурации:** (`app.properties`)

```Properties
# Алгоритм хэширования: MD5, SHA-1, SHA-256
hash.algorithm=MD5
# Паттерны для исключения при сканировании и сравнении (через запятую)
scan.ignore.patterns=*.log,*.tmp,*.bak
```

**Доп. задачи к CI/CD**:
- **Matrix на версии Java:** Собрать и протестировать приложение на нескольких версиях Java (JDK 11, 17, 21) используя `matrix` и `actions/setup-java`
- **Сборка Docker-образа:** Добавить шаг, который использует Jib (плагин Gradle) или `docker/build-push-action` (с `Dockerfile`) для сборки Docker-образа приложения

#### 4. Анализатор дискового пространства

**Описание:** Приложение парсит вывод системных утилит `df` (Linux/macOS) или `wmic logicaldisk` (Windows) для создания отчета об использовании диска.

**Функционал**:
- Выполнение системной команды для получения информации о дисках (команда определяется в зависимости от ОС)
- **Задание 1 (Парсинг):** извлечь данные: Имя диска, Общий размер, Использовано, Свободно, % использования
- **Задание 2 (Фильтрация):** найти и вывести только те файловые системы, у которых процент использования **выше** порога, заданного в `app.properties`
- **Задание 3 (Агрегация):** подсчитать и вывести общий/использованный/свободный объем дискового пространства по всем дискам

**Формат входных данных:**  *Пример (Linux `df -h`)*:

```txt
Filesystem      Size  Used Avail Use% Mounted on
udev            3.9G     0  3.9G   0% /dev
/dev/sda1        97G   20G   73G  22% /
```

**Формат выходных данных:** JSON-отчет в `stdout`

```JSON
{
  "threshold_exceeded": [
    {"filesystem": "/dev/sdb1", "total": "500G", "used_percent": 95}
  ],
  "summary": {
    "total_gb": 597,
    "total_used_gb": 520
  }
}
```

**Пример файла конфигурации:** (`app.properties`)

```Properties
# Порог использования в %, при превышении которого диск попадает в отчет
usage.threshold.percent=90
# Единицы измерения для отчета: GB, MB, TB
output.units=GB
```

**Доп. задачи к CI/CD**:
- **Matrix по ОС:** Запускать тесты на `ubuntu-latest` и `windows-latest`. Unit-тесты должны "подсовывать" приложению строки с реальным выводом `df` и `wmic` и проверять корректность парсинга для обеих ОС
- **Публикация артефакта:** Собрать исполняемый `jar` и опубликовать его как артефакт
- **Статический анализ:** Добавить шаг с `checkstyle` или `pmd` и "провалить" сборку, если есть нарушения

#### 5. Агрегатор CSV-данных о продажах

**Описание:** Приложение читает большой CSV-файл с данными о продажах, агрегирует и фильтрует их согласно настройкам.

**Функционал**:
- Чтение CSV-файла (путь из `app.properties`), где каждая строка - это транзакция.
- **Задание 1 (Агрегация):** подсчитать общую сумму продаж (колонка `Amount`), сгруппированную по `Region` (колонка `Region`)
- **Задание 2 (Сортировка/Поиск):** найти 10 самых дорогих продаж (`Amount`) и вывести их `TransactionID`
- **Задание 3 (Фильтрация):** отфильтровать и вывести все транзакции, где `ProductID` (из `app.properties`) совпадает с заданным

**Формат входных данных:** `sales.csv`

```
TransactionID,Date,ProductID,Amount,Region
1001,2025-10-10,P-123,150.00,North
1002,2025-10-10,P-456,20.50,South
1003,2025-10-11,P-123,150.00,West
```

**Формат выходных данных:** Текстовый отчет в `stdout` или в файл (зависит от конфига)

```txt
--- Sales by Region ---
North: 150.00
South: 20.50
West: 150.00

--- Top 10 Sales (ID) ---
1001
1003

--- Filtered by Product P-456 ---
1002,2025-10-10,P-456,20.50,South
```

**Пример файла конфигурации:** (`app.properties`)

```Properties
# Путь к входному CSV
csv.input.path=./data/sales.csv
# ID продукта для фильтрации
filter.product.id=P-456
# Количество записей для топа
report.top.sales.count=10
# Разделитель в CSV ( , или ; )
csv.separator=,
# Вывод в stdout
report.output=STDOUT
```

**Доп. задачи к CI/CD**:
- **Кэширование зависимостей:** Настроить `actions/cache` для `.gradle/caches`
- **Тестирование на разных JDK:** Использовать `matrix` для сборки и тестов на Java 11, 17, 21

#### 6. Анализатор логов Git

**Описание:** Приложение запускает `git log` в текущем репозитории и анализирует вывод, чтобы построить статистику по коммитам.

**Функционал**:
- Выполнение команды `git log`
- **Задание 1 (Агрегация):** подсчитать общее количество коммитов на каждого автора и вывести топ-3
- **Задание 2 (Поиск):** найти все коммиты (хэш и сообщение), содержащие ключевые слова (например, "FIX:", "BUG:", "HOTFIX:"), список слов берется из `app.properties`.
- **Задание 3 (Сортировка):** вывести список всех авторов (уникальных) в алфавитном порядке.

**Формат входных данных:**

```txt
a1b2c3d|Alice|FIX: Critical bug in login
e4f5g6h|Bob|Initial commit
i7j8k9l|Alice|Update README
```

**Формат выходных данных:** JSON-отчет в `stdout`

```JSON
{
  "top_authors": [
    {"name": "Alice", "commits": 2},
    {"name": "Bob", "commits": 1}
  ],
  "found_keywords": [
    {"hash": "a1b2c3d", "message": "FIX: Critical bug in login"}
  ],
  "all_authors": ["Alice", "Bob"]
}
```

**Пример файла конфигурации:** (`app.properties`)

```Properties
# Ключевые слова для поиска (через запятую)
git.search.keywords=FIX:,BUG:,HOTFIX:
# Формат вывода: JSON или PLAINTEXT
output.format=JSON
```

**Доп. задачи к CI/CD**:
- **Запуск в контейнере:** Убедиться, что `git` доступен в окружении (стандартный `ubuntu-latest` уже имеет `git` благодаря `actions/checkout`)
- **Тестирование на "себе":** Запустить приложение в CI и натравить его на лог _собственного_ репозитория
- **Публикация отчета:** Сгенерировать отчет в `JSON` и опубликовать его как артефакт `git-stats.json`

#### 7. Поиск "TODO" в исходном коде

**Описание:** Приложение рекурсивно сканирует указанную директорию, ищет в файлах (с определенными расширениями) комментарии "TODO", "FIXME" и генерирует отчет.

**Функционал**:
- Рекурсивный обход директории (путь из `app.properties`)
- **Задание 1 (Поиск):** найти все строки-комментарии в коде, содержащие "TODO", "FIXME"
- **Задание 2 (Группировка):** сгруппировать найденные строки по файлам
- **Задание 3 (Фильтрация):** искать только в файлах с расширениями, указанными в конфиге (например, `.java`, `.kt`, `.md`)

**Формат входных данных:**

```Java
public class MyClass {
    // TODO: Need to refactor this
    public void doWork() { ... }
    // FIXME: This is slow
    public void doMoreWork() { ... }
}
```

**Формат выходных данных:**

```txt
Found 3 issues:

[src/main/java/MyClass.java]
  L3: TODO: Need to refactor this
  L5: FIXME: This is slow

[README.md]
  L10: TODO: Remember to update screenshots
```

**Пример файла конфигурации:** (`app.properties`)

```Properties
# Директория для сканирования
scan.source.directory=./src
# Расширения файлов для сканирования (через запятую)
scan.file.extensions=.java,.kt,.xml,.md
# Ключевые слова для поиска (через запятую, регистронезависимо)
scan.keywords=TODO,FIXME
```

**Доп. задачи к CI/CD**:
- **Тестирование на "себе":** Запустить приложение в CI-пайплайне и просканировать _собственный_ исходный код
- **Matrix по ОС:** Проверить, что приложение корректно работает с путями (`\` и `/`) на `ubuntu-latest` и `windows-latest`.

#### 8. Монитор сетевых соединений (netstat)

**Описание:** Java-приложение, которое выполняет `netstat -ano` (Windows) или `netstat -anp` (Linux), парсит вывод и ищет заданные соединения.

**Функционал**:
- Выполнение `netstat` и парсинг `stdout`
- **Задание 1 (Поиск):** найти и вывести все PID/Процессы, которые держат порт в состоянии `LISTEN`
- **Задание 2 (Поиск):** найти все внешние (`ESTABLISHED`) и вывести их `Foreign Address`
- **Задание 3 (Поиск):** проверить, занят ли порт, указанный в `app.properties`. Если да, вывести PID процесса, который его занял
    
**Формат входных данных:** *Пример (Linux)*:

```txt
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 127.0.0.1:3306          0.0.0.0:* LISTEN      1234/mysqld
tcp        0      0 192.168.1.10:1234       104.18.3.10:443         ESTABLISHED 5678/java
```

**Формат выходных данных:** Отчет в `stdout`

```txt
--- Listening Ports ---
PID: 1234, Process: mysqld, Port: 3306

--- External Connections ---
PID: 5678, Process: java, Foreign: 104.18.3.10:443

--- Port 8080 Check ---
Port 8080 is not in use.
```

**Пример файла конфигурации:** (`app.properties`)

```Properties
# Порт, который нужно проверить на занятость
monitor.port.check=8080
# Режим вывода: VERBOSE (все) или SUMMARY (только проблемы)
output.mode=VERBOSE
```

**Доп. задачи к CI/CD**:
- **Matrix по ОС:** `ubuntu-latest` и `windows-latest`. Формат вывода `netstat` **абсолютно разный**, и парсер должен это учитывать
- **Сборка Docker-образа:** Добавить `Jib` (Gradle-плагин) или `Dockerfile` для сборки образа приложения

#### <mark style="background: #FFF3A3A6;">9. Преобразователь вложенного JSON в "плоский" (Flat-JSON)</mark>

**Описание:** Приложение читает сложный, вложенный JSON-файл и преобразует его в "плоскую" структуру (ключи с точками) и ищет в нем данные.

**Функционал**:
- Чтение JSON из файла (путь из переменной среды `INPUT_JSON`)
- **Задание 1 (Преобразование):** "Развернуть" JSON: `{ "user": { "name": "Test" } }` превращается в `{ "user.name": "Test" }`
- **Задание 2 (Поиск):** Найти значение по "плоскому" ключу (ключ задан в `app.properties`, например `search.key=user.address.city`)
- **Задание 3 (Фильтрация):** Обработать массив JSON-объектов, оставив только те, у которых `user.status == "ACTIVE"`.
    
**Формат входных данных:** `input.json`

```JSON
{
  "request_id": "tx-123",
  "payload": {
    "user": {
      "name": "Alice",
      "address": {
        "city": "New York",
        "zip": "10001"
      },
      "status": "ACTIVE"
    }
  }
}
```

**Формат выходных данных:** `stdout`

```JSON
{
  "request_id": "tx-123",
  "payload.user.name": "Alice",
  "payload.user.address.city": "New York",
  "payload.user.address.zip": "10001",
  "payload.user.status": "ACTIVE"
}
```

**Пример файла конфигурации:** (`app.properties`)

```Properties
# Ключ для поиска
search.key=payload.user.address.city
# Ключ для фильтрации
filter.key=payload.user.status
filter.value=ACTIVE
```

**Доп. задачи к CI/CD**:
- **Кэширование Gradle.**

#### 10. Генератор Mock-данных

**Описание:** Утилита генерирует N строк тестовых данных (CSV или JSON) на основе шаблона, заданного в `app.properties`

**Функционал**:
- Чтение конфигурации для генерации
- **Задание 1 (Генерация):** генерировать N записей
- **Задание 2 (Форматирование):** поддержка генерации в `CSV` и `JSON` (формат из конфига)
- **Задание 3 (Типы данных):** поддержка шаблонов полей: `uuid` (случайный UUID), `name` (случайное имя), `email` (случайный email), `int(min,max)` (случайное число в диапазоне)

**Формат выходных данных:**  *Пример вывода (для `output.format=CSV`)*:

```CSV
id,user_name,user_email
1,John Doe,john.doe@example.com
2,Jane Smith,jane.smith@example.com
... (еще 9998 строк)
```

**Пример файла конфигурации:** (`app.properties`)

```Properties
# Количество строк для генерации
generator.rows.count=10000
# Формат вывода: CSV или JSON
output.format=CSV
# Описание полей. Формат: <имя_колонки>:<тип_генератора>
generator.fields=id:int(1,100000),user_name:name,user_email:email
```

**Доп. задачи к CI/CD**:
- **Публикация JAR:** Собрать `jar` и опубликовать как артефакт
- **Тестирование на разных JDK** (11, 17, 21)

#### 11. Сбор информации о системе

**Описание:** Приложение собирает базовую информацию о системе (CPU, RAM, OS), используя системные утилиты, и выводит ее в едином JSON-формате.

**Функционал**:
- Определение ОС и выбор правильной команды (`lscpu`/`cat /proc/meminfo` для Linux, `systeminfo` для Windows)
- **Задание 1 (Парсинг CPU):** извлечь модель CPU и количество ядер
- **Задание 2 (Парсинг RAM):** извлечь общий объем оперативной памяти
- **Задание 3 (Парсинг OS):** Извлечь название и версию ОС

**Формат выходных данных:** `stdout`

```JSON
{
  "os": {
    "name": "Ubuntu",
    "version": "22.04"
  },
  "cpu": {
    "model": "Intel(R) Core(TM) i7-10750H",
    "cores": 12
  },
  "memory": {
    "total_mb": 15998
  }
}
```

**Пример файла конфигурации:** (`app.properties`)

```Properties
# Формат вывода памяти: MB или GB
memory.output.unit=MB
# Включить ли в отчет информацию об IP (требует доп. команды)
include.network.info=false
```

**Доп. задачи к CI/CD**:
- **Matrix по ОС:** `ubuntu-latest` и `windows-latest`. Парсеры должны работать для обеих ОС
- **Публикация отчета:** сохранить JSON-вывод в файл `inventory.json` и опубликовать как артефакт

#### 12. Анализатор процессов (ps/tasklist)

**Описание:** Приложение парсит вывод `ps aux` (Linux) или `tasklist` (Windows) и ищет процессы, потребляющие много ресурсов.

**Фуционал**:
- Выполнение `ps` или `tasklist` и парсинг `stdout`
- **Задание 1 (Сортировка):** отсортировать все процессы по % CPU (убывание) или RAM (убывание) – режим из `app.properties`.
- **Задание 2 (Поиск):** найти PID процесса по его имени (имя из `app.properties`, например, "java")
- **Задание 3 (Фильтрация):** найти и вывести все процессы, потребляющие > N% CPU **или** > M MB RAM (пороги N и M из `app.properties`)

**Формат входных данных:** *Пример (Windows `tasklist`)*:

```
Image Name                     PID Session Name        Session#    Mem Usage
========================= ======== ================= =========== ============
System                           4 Services                   0      1,234 K
java.exe                    123456 Console                    1    512,345 K
```

**Формат выходных данных:** Текстовый отчет в `stdout`

```
--- Top 5 by CPU ---
PID: 1234, CPU: 15.2%, MEM: 500M, Name: java
...

--- Processes above threshold (CPU > 10% or MEM > 1000M) ---
...
```

**Пример файла конфигурации:**

```Properties
# Режим сортировки: CPU или MEMORY
sort.by=CPU
# Пороги для фильтрации
threshold.cpu.percent=10
threshold.memory.mb=1000
# Имя процесса для поиска PID
search.process.name=java
```

**Доп. задачи к CI/CD**:
- **Matrix по ОС:** `ubuntu-latest` и `windows-latest`. Разные команды и форматы вывода
- **Статический анализ (PMD/Checkstyle)**

#### 13. Фильтр и форматер логов

**Описание:** Утилита читает структурированный лог (например, стандартный лог Spring Boot) из `stdin` и фильтрует/переформатирует его в `stdout`.

**Функционал**:
- Чтение `stdin` построчно (для работы в "пайплайне" `cat app.log | java -jar ...`)
- **Задание 1 (Фильтрация по уровню):** Выводить только строки, содержащие `ERROR` (или `WARN`, `INFO` – уровень из `app.properties`)
- **Задание 2 (Поиск по контексту):** Выводить только строки, содержащие ID (например, `[TraceID: xyz-123]`) или текст из `app.properties`.
- **Задание 3 (Преобразование):** Переформатировать вывод. Например, из `2025-10-10 10:00:00 INFO [main] ...` сделать `[INFO] ...`.
    

**Формат входных данных:** `stdin` (лог-поток).

```
2025-10-10 10:00:00.100 INFO [main] com.app.Main: Starting app...
2025-10-10 10:00:01.200 WARN [task-1] com.app.Task: Task running slow...
2025-10-10 10:00:02.300 ERROR [main] com.app.Main: Failed to start!
```

**Формат выходных данных:** `stdout` (отфильтрованный/измененный лог). _При `filter.level=ERROR`:_

```
[ERROR] Failed to start!
```

**Пример файла конфигурации:** (`app.properties`)

Properties

```
# Уровень логгирования для фильтрации: INFO, WARN, ERROR (пусто = все)
filter.level=ERROR
# Текст для поиска (пусто = не используется)
filter.contains.text=
# Формат вывода: SIMPLE (только сообщение), COMPACT ([LEVEL] сообщение), FULL (как было)
output.format=COMPACT
```

**Доп. задачи к CI/CD**:

- **Тестирование с `stdin`:** В CI-шаге использовать `cat test.log | java -jar app.jar > out.log` и затем `grep` файл `out.log` на наличие/отсутствие ожидаемых строк.
    
- **Тестирование на разных JDK.**
    
- **Кэширование Gradle.**

### Отчет по лабораторной работе должен содержать

1. Цель и задачи работы.
2. Структура проекта и используемые зависимости.
3. Список тестов и их описание.
4. Скриншоты с результатами прохожождения тестов и работы приложения.
5. Описание workflow-файла.
6. Вывод по выполненной работе.

### Список вопросов на защиту

1. Что такое CI/CD и зачем оно нужно?
2. Какие этапы обычно включает pipeline CI/CD?
3. Что такое GitHub Actions и как он работает?
4. Что такое workflow и job в GitHub Actions?
5. Какие преимущества использования Gradle по сравнению с Maven?
6. Что такое артефакт сборки?
7. Что такое unit‑тесты и зачем они нужны?
8. Что такое Javadoc и зачем его использовать?
9. Какие события могут запускать workflow в GitHub Actions?
10. Что такое secrets в GitHub Actions?